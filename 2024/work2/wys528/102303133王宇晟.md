仓库地址：https://github.com/wys528/bili

# 学习笔记

# Activity

## Activity是什么

Activity是最容易吸引用户的地方，它是一种可以包含用户界面的组件，主要用于和用户进行交 互。一个应用程序中可以包含零个或多个Activity，但不包含任何Activity的应用程序很少见， 谁也不想让自己的应用永远无法被用户看到吧

## Activity的基本使用方法

到现在为止，你还没有手动创建过Activity呢，因为第1章中的MainActivity是Android Studio 自动帮我们创建的。手动创建Activity可以加深我们的理解，因此现在是时候自己动手了。选择“Add No Activity”

### 手动创建Activity

现在右击com.example.activitytest包→New→Activity→Empty Activity，会弹出一个创建 Activity的对话框，我们将Activity命名为FirstActivity，并且不要勾选Generate Layout File 和Launcher Activity这两个选项

勾选Generate Layout File表示会自动为FirstActivity创建一个对应的布局文件，勾选 Launcher Activity表示会自动将FirstActivity设置为当前项目的主Activity。由于你是第一次 手动创建Activity，这些自动生成的东西暂时都不要勾选，下面我们将会一个个手动来完成。勾 选Backwards Compatibility表示会为项目启用向下兼容旧版系统的模式，这个选项要勾上

你需要知道，项目中的任何Activity都应该重写onCreate()方法，而目前我们的FirstActivity 中已经重写了这个方法，这是Android Studio自动帮我们完成的，代码如下所示

```kotlin
class FirstActivity:AppCompatActivity(){
    override fun onCreate(savedInstanceState:Bundle?){
        super.onCreate(savedInstanceState)
    }
}
```

### 创建和加载布局

前面我们说过，Android程序的设计讲究逻辑和视图分离，最好每一个Activity都能对应一个布 局。布局是用来显示界面内容的，我们现在就来手动创建一个布局文件。

右击app/src/main/res目录→New→Directory，会弹出一个新建目录的窗口，这里先创建一个 名为layout的目录。然后对着layout目录右键→New→Layout resource file，又会弹出一个 新建布局资源文件的窗口，我们将这个布局文件命名为first_layout，根元素默认选择为 LinearLayout

可看到如下代码

```kotlin
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
      android:orientation="vertical" 
      android:layout_width="match_parent" 
      android:layout_height="match_parent"> 
</LinearLayout> 
```

由于我们刚才在创建布局文件时选择了LinearLayout作为根元素，因此现在布局文件中已经有 一个LinearLayout元素了。我们现在对这个布局稍做编辑，添加一个按钮，如下所示：

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
      android:orientation="vertical" 
      android:layout_width="match_parent" 
      android:layout_height="match_parent"> 
	<Button
            android:id="@+id/button1"
            android:layout_width="match_parent"
            androdi:layout_height="wrap_content"
            androdi:text="Button 1"
     />
</LinearLayout>
```

可以看到，按钮已经成功显示出来了，这样一个简单的布局就编写完成了。那么接下来我们要 做的，就是在Activity中加载这个布局

```kotlin
class FirstActivity:AppCompatActivity{
    override fun onCreate(savedInstanceState:Bundle?){
        super.onCreate(savedInstanceState)
        setContentView(R.layout.first_layout)
    }
}
```

可以看到，这里调用了setContentView()方法来给当前的Activity加载一个布局，而在 setContentView()方法中，我们一般会传入一个布局文件的id。在第1章介绍项目资源的时 候我曾提到过，项目中添加的任何资源都会在R文件中生成一个相应的资源id，因此我们刚才创 建的first_layout.xml布局的id现在已经添加到R文件中了。在代码中引用布局文件的方法 你也已经学过了，只需要调用R.layout.first_layout就可以得到first_layout.xml布 局的id，然后将这个值传入setContentView()方法即可

### 在AndroidManifest文件中注册

我们打开 app/src/main/AndroidManifest.xml文件瞧一瞧，代码如下所示

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android" 
         package="com.example.activitytest"> 
    <application 
            android:allowBackup="true" 
            android:icon="@mipmap/ic_launcher" 
            android:label="@string/app_name" 
            android:roundIcon="@mipmap/ic_launcher_round" 
            android:supportsRtl="true" 
            android:theme="@style/AppTheme"> 
        <activity android:name=".FirstActivity"> 
        </activity> 
    </application> 
</manifest> 
```

可以看到，Activity的注册声明要放在标签内，这里是通过标签 来对Activity进行注册的。那么又是谁帮我们自动完成了对FirstActivity的注册呢？当然是 Android Studio了。在过去，当创建Activity或其他系统组件时，很多人会忘记要去Android Manifest.xml中进行注册，从而导致程序运行崩溃，很显然Android Studio在这方面做得更加 人性化

在标签中，我们使用了android:name来指定具体注册哪一个Activity，那么这 里填入的.FirstActivity是什么意思呢？其实这不过是 com.example.activitytest.FirstActivity的缩写而已。由于在最外层的 标签中已经通过package属性指定了程序的包名是com.example.activitytest，因此在注 册Activity时，这一部分可以省略，直接使用.FirstActivity就足够了

不过，仅仅是这样注册了Activity，我们的程序仍然不能运行，因为还没有为程序配置主 Activity。也就是说，程序运行起来的时候，不知道要首先启动哪个Activity。配置主Activity 的方法其实在第1章中已经介绍过了，就是在标签的内部加入 标签，并在这个标签里添加和这两句声明即可。

除此之外，我们还可以使用android:label指定Activity中标题栏的内容，标题栏是显示在 Activity最顶部的，待会儿运行的时候你就会看到。需要注意的是，给主Activity指定的label不 仅会成为标题栏中的内容，还会成为启动器（Launcher）中应用程序显示的名称。

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android" 
         package="com.example.activitytest"> 
    <application 
            android:allowBackup="true" 
            android:icon="@mipmap/ic_launcher" 
            android:label="@string/app_name" 
            android:roundIcon="@mipmap/ic_launcher_round" 
            android:supportsRtl="true" 
            android:theme="@style/AppTheme"> 
        <activity android:name=".FirstActivity"
                  android:label="This is FirstActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="androiod.intent.category.LAUNCHER"/>
            </intent-filter>      
        </activity> 
    </application> 
</manifest>   
```

这样，FirstActivity就成为我们这个程序的主Activity了，点击桌面应用程序图标时首先打开的 就是这个Activity。另外需要注意，如果你的应用程序中没有声明任何一个Activity作为主 Activity，这个程序仍然是可以正常安装的，只是你无法在启动器中看到或者打开这个程序。这 种程序一般是作为第三方服务供其他应用在内部进行调用的。

### 在Activity 中使用Toast

Toast是Android系统提供的一种非常好的提醒方式，在程序中可以使用它将一些短小的信息通 知给用户，这些信息会在一段时间后自动消失，并且不会占用任何屏幕空间，我们现在就尝试 一下如何在Activity中使用Toast。

首先需要定义一个弹出Toast的触发点，正好界面上有个按钮，那我们就让这个按钮的点击事件 作为弹出Toast的触发点吧。在onCreate()方法中添加如下代码：

```kotlin
override fun onCreate(savedInstaceState:Bundle?){
    super.onCreate(savedInstaceState)
    steContentView(R.layout.first_layout)
    val button1:Buntton = findViewById(R.id.button1)
    button1.setOnClickListener{
        Toast.makeText(this,"You clicked Button 1",Toast.LENGTH_SHORT).show()
    }
}
```

在Activity中，可以通过findViewById()方法获取在布局文件中定义的元素，这里我们传入 R.id.button1来得到按钮的实例，这个值是刚才在first_layout.xml中通过android:id属 性指定的。findViewById()方法返回的是一个继承自View的泛型对象，因此Kotlin无法自动 推导出它是一个Button还是其他控件，所以我们需要将button1变量显式地声明成Button类 型。得到按钮的实例之后，我们通过调用setOnClickListener()方法为按钮注册一个监听 器，点击按钮时就会执行监听器中的onClick()方法。因此，弹出Toast的功能当然是要在 onClick()方法中编写了。 Toast的用法非常简单，通过静态方法makeText()创建出一个Toast对象，然后调用show() 将Toast显示出来就可以了。这里需要注意的是，makeText()方法需要传入3个参数。第一个 参数是Context，也就是Toast要求的上下文，由于Activity本身就是一个Context对象，因此 这里直接传入this即可。第二个参数是Toast显示的文本内容。第三个参数是Toast显示的时 长，有两个内置常量可以选择：Toast.LENGTH_SHORT和Toast.LENGTH_LONG

于findViewById()方法的使用，我还得再多讲一些。我们已经知道，findViewById()方 法的作用就是获取布局文件中控件的实例，但是前面的例子比较简单，只有一个按钮，如果某 个布局文件中有10个控件呢？没错，我们就需要调用10次findViewById()方法才行。这种 写法虽然很正确，但是很笨拙，于是就滋生出了诸如ButterKnife之类的第三方开源库，来简化 findViewById()方法的调用。

不过，这个问题在Kotlin中就不复存在了，因为使用Kotlin编写的Android项目在 app/build.gradle文件的头部默认引入了一个kotlin-android-extensions插件，这个插件会根 据布局文件中定义的控件id自动生成一个具有相同名称的变量，我们可以在Activity里直接使用 这个变量，而不用再调用findViewById()方法了

### 在Activity中使用Menu

首先在res目录下新建一个menu文件夹，右击res目录→New→Directory，输入文件夹 名“menu”，点击“OK”。接着在这个文件夹下新建一个名叫“main”的菜单文件，右击menu文 件夹→New→Menu resource file

文件名输入“main”，点击“OK”完成创建，然后在main.xml中添加如下代码

```xml
<menu xmlns:android="http://schemas.androdi.com/apk/res/android">
    <item
          android:id="@+id/add_item"
          android:title="Add"/>
    <item
          android:id="@+id/remove_item"
          android:title="Remove"/>
</menu>
```

这里我们创建了两个菜单项，其中标签用来创建具体的某一个菜单项，然后通过 android:id给这个菜单项指定一个唯一的标识符，通过android:title给这个菜单项指定一 个名称

接着回到FirstActivity中来重写onCreateOptionsMenu()方法，重写方法可以使用Ctrl + O 快捷键

然后在onCreateOptionsMenu()方法中编写如下代码：

```kotlin
override fun onCreateOptionsMenu(menu:Menu?):Boolean{
    menuInflater.inflate(R.menu.main,menu)
    return true
}
```

在继续讲解这段代码之前，我还得再介绍一个Kotlin的语法糖。如果你熟悉Java的话，应该知道 Java Bean的概念，它是一个非常简单的Java类，会根据类中的字段自动生成相应的Getter和 Setter方法，如下所示：

```java
 public class Book { 
 
   private int pages; 
 
   public int getPages() { 
      return pages; 
   } 
 
   public void setPages(int pages) { 
      this.pages = pages; 
   } 
}
```

在Kotlin中调用这种语法结构的Java方法时，可以使用一种更加简便的写法，比如用如下代码来 设置和读取Book类中的pages字段：

```kotlin
val book = Book()
book.pages=500
val bookPages=book.pages
```

这里看上去好像我们并没有调用Book类的setPages()和getPages()方法，而是直接对 pages字段进行了赋值和读取。其实这就是Kotlin给我们提供的语法糖，它会在背后自动将上述 代码转换成调用setPages()方法和getPages()方法

而我们刚才在onCreateOptionsMenu()方法中编写的menuInflater就使用了这种语法糖， 它实际上是调用了父类的getMenuInflater()方法。getMenuInflater()方法能够得到一 个MenuInflater对象，再调用它的inflate()方法，就可以给当前Activity创建菜单了。 inflate()方法接收两个参数：第一个参数用于指定我们通过哪一个资源文件来创建菜单，这 里当然是传入R.menu.main；第二个参数用于指定我们的菜单项将添加到哪一个Menu对象当 中，这里直接使用onCreateOptionsMenu()方法中传入的menu参数。最后给这个方法返回 true，表示允许创建的菜单显示出来，如果返回了false，创建的菜单将无法显示。

当然，仅仅让菜单显示出来是不够的，我们定义菜单不仅是为了看的，关键是要菜单真正可用 才行，因此还要再定义菜单响应事件。在FirstActivity中重写onOptionsItemSelected()方 法，如下所示

```kotlin
override fun onOptionsItemSelected(item:MenuItem):Boolean{
    when(item.itemId){
        R.id.add_item->Toast.makeText(this,"You clicked Add",Toast.LENGTH_SHORT).show()
        R.id.remove_item->Toast.makeText(this,"You clcked Remove",Toast.LENGTH_SHORT).show()
    }
    return true
}
```

在onOptionsItemSelected()方法中，我们通过调用item.itemId来判断点击的是哪一个 菜单项。另外，其实这里也应用了刚刚学到的语法糖，Kotlin实际上在背后调用的是item的 getItemId()方法。接下来我们将item.itemId的结果传入when语句当中，然后给每个菜单 项加入自己的逻辑处理，这里我们就活学活用，弹出一个刚刚学会的Toas

### 销毁一个Activity

修改按钮监听器中的代码，如下所示

```kotlin
button1.setOnClickListener{
	finish()
}
```

## 使用Intent在Activity之间穿梭

### 使用显示Intent

你应该已经对创建Activity的流程比较熟悉了，那我们现在在ActivityTest项目中再快速地创建 一个Activity。 还是右击com.example.activitytest包→New→Activity→Empty Activity，会弹出一个创建 Activity的对话框，这次我们命名为SecondActivity，并勾选Generate Layout File，给布局 文件起名为second_layout，但不要勾选Launcher Activity选项

现在第二个Activity已经创建完成，剩下的问题就是如何去启 动它了，这里我们需要引入一个新的概念：Intent

Intent是Android程序中各组件之间进行交互的一种重要方式，它不仅可以指明当前组件想要执 行的动作，还可以在不同组件之间传递数据。Intent一般可用于启动Activity、启动Service以 及发送广播等场景，由于Service、广播等概念你暂时还未涉及，那么本章我们的目光无疑就锁 定在了启动Activity上面。

Intent大致可以分为两种：显式Intent和隐式Intent。我们先来看一下显式Intent如何使用

Intent有多个构造函数的重载，其中一个是Intent(Context packageContext, Class cls)。这个构造函数接收两个参数：第一个参数Context要求提供一个启动Activity的上下 文；第二个参数Class用于指定想要启动的目标Activity，通过这个构造函数就可以构建出 Intent的“意图”。那么接下来我们应该怎么使用这个Intent呢？Activity类中提供了一个 startActivity()方法，专门用于启动Activity，它接收一个Intent参数，这里我们将构建好 的Intent传入startActivity()方法就可以启动目标Activity了

修改FirstActivity中按钮的点击事件，代码如下所示：

```kotlin
button1.setOnClickListener{
    val intent = Intent(this,SecondActitivy::class.java)
    startActivity(intent)
}
```

我们首先构建了一个Intent对象，第一个参数传入this也就是FirstActivity作为上下文，第二 个参数传入SecondActivity::class.java作为目标Activity，这样我们的“意图”就非常明 显了，即在FirstActivity的基础上打开SecondActivity。注意，Kotlin中 SecondActivity::class.java的写法就相当于Java中SecondActivity.class的写法。 接下来再通过startActivity()方法执行这个Intent就可以了

重新运行程序，在FirstActivity的界面点击一下按钮，可以看到，我们已经成功启动SecondActivity了。如果你想要回到上一个Activity怎么办呢？ 很简单，按一下Back键就可以销毁当前Activity，从而回到上一个Activity了。 使用这种方式来启动Activity，Intent的“意图”非常明显，因此我们称之为显式Intent

### 使用隐式Intent

相比于显式Intent，隐式Intent则含蓄了许多，它并不明确指出想要启动哪一个Activity，而是 指定了一系列更为抽象的action和category等信息，然后交由系统去分析这个Intent，并帮 我们找出合适的Activity去启动

什么叫作合适的Activity呢？简单来说就是可以响应这个隐式Intent的Activity，那么目前 SecondActivity可以响应什么样的隐式Intent呢？额，现在好像还什么都响应不了，不过很快就可以了。

通过在标签下配置的内容，可以指定当前Activity能够响应的 action和category，打开AndroidManifest.xml，添加如下代码

```xml
<activity android:name=".SecondeActivity">
    <intent-filter>
        <action android:name="con.example.activityest.ACCTION_START"/>
        <category android:name="android.intent.category.DEFAULT"/>
    </intent-filter>
</activity>
```

在标签中我们指明了当前Activity可以响应 com.example.activitytest.ACTION_START这个action，而标签则包含了 一些附加信息，更精确地指明了当前Activity能够响应的Intent中还可能带有的category。只 有和中的内容同时匹配Intent中指定的action和category时，这个 Activity才能响应该Intent

修改FirstActivity中按钮的点击事件，代码如下所示：

```kotlin
button1.setOnClickListener{
    val intent = Intent("com.example.activitytest.ACTION_START")
    startActivity(intent)
}
```

可以看到，我们使用了Intent的另一个构造函数，直接将action的字符串传了进去，表明我们 想要启动能够响应com.example.activitytest.ACTION_START这个action的Activity。 前面不是说要和同时匹配才能响应吗？怎么没看到哪里有指定 category呢？这是因为android.intent.category.DEFAULT是一种默认的category， 在调用startActivity()方法的时候会自动将这个category添加到Intent中。

每个Intent中只能指定一个action，但能指定多个category。目前我们的Intent中只有一个 默认的category，那么现在再来增加一个吧。

```kotlin
button1.setOnClickListener{
    val intent = Intent("com.example.activitytest.ACTION_START")
    intent.addCategory("com.example.activitytest.MY_CATEGORY")
    startActivity(intent)
}
```

### 更多的Intent的用法

使用隐式Intent，不仅可以启动自己程序内的Activity，还可以启动其他程序的Activity，这就 使多个应用程序之间的功能共享成为了可能。比如你的应用程序中需要展示一个网页，这时你 没有必要自己去实现一个浏览器（事实上也不太可能），只需要调用系统的浏览器来打开这个 网页就行了。

修改FirstActivity中按钮点击事件的代码，如下所示：

```kotlin
button1.setOnClckListener{
    val intent = Intent(Intent.ACTION_VIEW)
    intent.data = Uri.parse("https:www.baidu.com")
    startActivity(intent)
}
```

这里我们首先指定了Intent的action是Intent.ACTION_VIEW，这是一个Android系统内置 的动作，其常量值为android.intent.action.VIEW。然后通过Uri.parse()方法将一个 网址字符串解析成一个Uri对象，再调用Intent的setData()方法将这个Uri对象传递进去。 当然，这里再次使用了前面学习的语法糖，看上去像是给Intent的data属性赋值一样。 重新运行程序，在FirstActivity界面点击按钮就可以看到打开了系统浏览器

在上述代码中，可能你会对setData()方法部分感到陌生，这是我们前面没有讲到的。这个方 法其实并不复杂，它接收一个Uri对象，主要用于指定当前Intent正在操作的数据，而这些数据 通常是以字符串形式传入Uri.parse()方法中解析产生的。

与此对应，我们还可以在标签中再配置一个标签，用于更精确地指 定当前Activity能够响应的数据。<data>标签中主要可以配置以下内容。

android:scheme。用于指定数据的协议部分，如上例中的https部分。 android:host。用于指定数据的主机名部分，如上例中的部分。 android:port。用于指定数据的端口部分，一般紧随在主机名之后。 android:path。用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内 容。 android:mimeType。用于指定可以处理的数据类型，允许使用通配符的方式进行指定。

只有当<data>标签中指定的内容和Intent中携带的Data完全一致时，当前Activity才能够响应 该Intent。不过，在标签中一般不会指定过多的内容。例如在上面的浏览器示例中，其 实只需要指定android:scheme为https，就可以响应所有https协议的Intent了。

右击com.example.activitytest包→New→Activity→Empty Activity，新建ThirdActivity， 并勾选Generate Layout File，给布局文件起名为third_layout，点击“Finish”完成创建。然 后编辑third_layout.xml，将里面的代码替换成如下内容

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:orientation="vertical" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent"> 
    <Button 
        android:id="@+id/button3" 
        android:layout_width="match_parent" 
        android:layout_height="wrap_content" 
        android:text="Button 3" 
    /> 
</LinearLayout> 
```

ThirdActivity中的代码保持不变即可，最后在AndroidManifest.xml中修改ThirdActivity的注 册信息

```xml
<activity android:name=".ThirdActivity">
    <intent-filter tools:ignore="AppLinkUrlError">
        <action android:name="android.intent.action.ViEW"/>
        <category android:name="android.intent.category.DEFAULT"/>
        <data android:scheme="https/">
    </intent-filter>
</activity>
```

我们在ThirdActivity的中配置了当前Activity能够响应的action是 Intent.ACTION_VIEW的常量值，而category则毫无疑问地指定了默认的category值，另 外在标签中，我们通过android:scheme指定了数据的协议必须是https协议，这样 ThirdActivity应该就和浏览器一样，能够响应一个打开网页的Intent了。另外，由于Android Studio认为所有能够响应ACTION_VIEW的Activity都应该加上BROWSABLE的category，否 则就会给出一段警告提醒。加上BROWSABLE的category是为了实现deep link功能，和我们 目前学习的东西无关，所以这里直接在标签上使用tools:ignore属性将 警告忽略即可。

可以看到，系统自动弹出了一个列表，显示了目前能够响应这个Intent的所有程序。选择 Chrome还会像之前一样打开浏览器，并显示百度的主页，而如果选择了ActivityTest，则会启 动ThirdActivity。JUST ONCE表示只是这次使用选择的程序打开，ALWAYS则表示以后一直使 用这次选择的程序打开。需要注意的是，虽然我们声明了ThirdActivity是可以响应打开网页的 Intent的，但实际上这个Activity并没有加载并显示网页的功能，所以在真正的项目中尽量不要 出现这种有可能误导用户的行为，不然会让用户对我们的应用产生负面的印象

除了https协议外，我们还可以指定很多其他协议，比如geo表示显示地理位置、tel表示拨打电 话。下面的代码展示了如何在我们的程序中调用系统拨号界面。

```kotlin
button1.setOnClickListener{
    val intent = Intent(Intent.ACTION_DIAL)
    intent.data = Uri.parse("tel:10086")
    startActivity(intent)
}
```

首先指定了Intent的action是Intent.ACTION_DIAL，这又是一个Android系统的内置动 作。然后在data部分指定了协议是tel，号码是10086。重新运行一下程序，在FirstActivity 的界面点击一下按钮

### 向下一个Activity传递数据

经过前面几节的学习，你已经对Intent有了一定的了解。不过到目前为止，我们只是简单地使 用Intent来启动一个Activity，其实Intent在启动Activity的时候还可以传递数据，下面我们来 一起看一下。

在启动Activity时传递数据的思路很简单，Intent中提供了一系列putExtra()方法的重载，可 以把我们想要传递的数据暂存在Intent中，在启动另一个Activity后，只需要把这些数据从 Intent中取出就可以了。比如说FirstActivity中有一个字符串，现在想把这个字符串传递到 SecondActivity中，你就可以这样编写：

```kotlin
button1.setOnClickListener{
    val data = "Hello SecondActivity"
    val intent = Intent(this,SecondActivity::class.java)
    intent.putExtra("extra_data",data)
    startActivity(intent)
}
```

这里我们还是使用显式Intent的方式来启动SecondActivity，并通过putExtra()方法传递了 一个字符串。注意，这里putExtra()方法接收两个参数，第一个参数是键，用于之后从 Intent中取值，第二个参数才是真正要传递的数据

然后在SecondActivity中将传递的数据取出，并打印出来，代码如下所示

```kotlin
class SecondActivity:AppCompatActivity(){
    override fun onCreate(savedInstanceState:Bundle?){
        super.onCreate(savedInstaceState)
        setContentView(R.layout.second_layout)
        val extraData = intent.getStringExtra("extra_data")
        Log.d("SecondActivity","extra data is $extraData")
    }
}
```

上述代码中的intent实际上调用的是父类的getIntent()方法，该方法会获取用于启动 SecondActivity的Intent，然后调用getStringExtra()方法并传入相应的键值，就可以得 到传递的数据了。这里由于我们传递的是字符串，所以使用getStringExtra()方法来获取传 递的数据。如果传递的是整型数据，则使用getIntExtra()方法；如果传递的是布尔型数据， 则使用getBooleanExtra()方法，以此类推。

### 返回数据给上一个Activity

既然可以传递数据给下一个Activity，那么能不能够返回数据给上一个Activity呢？答案是肯定 的。不过不同的是，返回上一个Activity只需要按一下Back键就可以了，并没有一个用于启动 Activity的Intent来传递数据，这该怎么办呢？其实Activity类中还有一个用于启动Activity的 startActivityForResult()方法，但它期望在Activity销毁的时候能够返回一个结果给上 一个Activity。毫无疑问，这就是我们所需要的。

startActivityForResult()方法接收两个参数：第一个参数还是Intent；第二个参数是请 求码，用于在之后的回调中判断数据的来源。我们还是来实战一下，修改FirstActivity中按钮的 点击事件，代码如下所示

```kotlin
button1.setOnCLickListener{
    val intent = Intent(this,SecondActivity::class.java)
    startActivityForResult(intent,1)
}
```

这里我们使用了startActivityForResult()方法来启动SecondActivity，请求码只要是一 个唯一值即可，这里传入了1。接下来我们在SecondActivity中给按钮注册点击事件，并在点 击事件中添加返回数据的逻辑，代码如下所示：

```kotlin
class SecnodActivity:AppCompatActivity(){
    override fum onCreate(savedInstancerState:Bundle?){
        super.onCreate(savedInstanceState)
        setContentView(R.layout.second_layout)
        button2.setOnClickListener{
            val intent = Intent()
            intent.putExtra("data_return","Hello FirstActivity")
            setResult(RESULT_OK,intent)
            finish()
        }
    }
}
```

可以看到，我们还是构建了一个Intent，只不过这个Intent仅仅用于传递数据而已，它没有指定 任何的“意图”。紧接着把要传递的数据存放在Intent中，然后调用了setResult()方法。这个 方法非常重要，专门用于向上一个Activity返回数据。setResult()方法接收两个参数：第一 个参数用于向上一个Activity返回处理结果，一般只使用RESULT_OK或RESULT_CANCELED这 两个值；第二个参数则把带有数据的Intent传递回去。最后调用了finish()方法来销毁当前 Activity。

由于我们是使用startActivityForResult()方法来启动SecondActivity的，在 SecondActivity被销毁之后会回调上一个Activity的onActivityResult()方法，因此我们 需要在FirstActivity中重写这个方法来得到返回的数据，如下所示

```kotlin
override fun onActivityResult(requestCode:int,resultCode:Int,data:Intent?){
    super.onActivityResult(requestCode,resultCode,data)
    when(requestCode){
        1->if(request==RESULT_OK){
            val returnedData = data?.getStringExtra("dat_return")
            Log.d("FirstActivity","returned data is $returnedData")
        }
    }
}
```

onActivityResult()方法带有3个参数：第一个参数requestCode，即我们在启动Activity 时传入的请求码；第二个参数resultCode，即我们在返回数据时传入的处理结果；第三个参 数data，即携带着返回数据的Intent。由于在一个Activity中有可能调用 startActivityForResult()方法去启动很多不同的Activity，每一个Activity返回的数据都 会回调到onActivityResult()这个方法中，因此我们首先要做的就是通过检查 requestCode的值来判断数据来源。确定数据是从SecondActivity返回的之后，我们再通过 resultCode的值来判断处理结果是否成功。最后从data中取值并打印出来，这样就完成了向 上一个Activity返回数据的工作

你可能会问，如果用户在SecondActivity中并不是通过点击按钮，而是通过按下Back键回到 FirstActivity，这样数据不就没法返回了吗？没错，不过这种情况还是很好处理的，我们可以通 过在SecondActivity中重写onBackPressed()方法来解决这个问题，代码如下所示：

```kotlin
override fun onBackPressed(){
    val intent = Intent()
    intent.putExtra("data_return","Hello FirstActivity")
    setResult(RESULT_OK,intent)
    finish()
}
```

这样，当用户按下Back键后，就会执行onBackPressed()方法中的代码，我们在这里添加返 回数据的逻辑就行了。

## Activity的生命周期

掌握Activity的生命周期对任何Android开发者来说都非常重要，当你深入理解Activity的生命 周期之后，就可以写出更加连贯流畅的程序，并在如何合理管理应用资源方面发挥得游刃有 余。你的应用程序也将会拥有更好的用户体验。

### 返回栈

经过前面几节的学习，相信你已经发现了Android中的Activity是可以层叠的。我们每启动一个 新的Activity，就会覆盖在原Activity之上，然后点击Back键会销毁最上面的Activity，下面的 一个Activity就会重新显示出来。

其实Android是使用任务（task）来管理Activity的，一个任务就是一组存放在栈里的Activity 的集合，这个栈也被称作返回栈（back stack）。栈是一种后进先出的数据结构，在默认情况 下，每当我们启动了一个新的Activity，它就会在返回栈中入栈，并处于栈顶的位置。而每当我 们按下Back键或调用finish()方法去销毁一个Activity时，处于栈顶的Activity就会出栈，前 一个入栈的Activity就会重新处于栈顶的位置。系统总是会显示处于栈顶的Activity给用户。

### Activity 状态

每个Activity在其生命周期中最多可能会有4种状态。

####  运行状态

当一个Activity位于返回栈的栈顶时，Activity就处于运行状态。系统最不愿意回收的就是 处于运行状态的Activity，因为这会带来非常差的用户体验

#### 暂停状态

当一个Activity不再处于栈顶位置，但仍然可见时，Activity就进入了暂停状态。你可能会 觉得，既然Activity已经不在栈顶了，怎么会可见呢？这是因为并不是每一个Activity都会 占满整个屏幕，比如对话框形式的Activity只会占用屏幕中间的部分区域。处于暂停状态的 Activity仍然是完全存活着的，系统也不愿意回收这种Activity（因为它还是可见的，回收 可见的东西都会在用户体验方面有不好的影响），只有在内存极低的情况下，系统才会去 考虑回收这种Activity。

#### 停止状态

当一个Activity不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然 会为这种Activity保存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要 内存时，处于停止状态的Activity有可能会被系统回收

#### 销毁状态

一个Activity从返回栈中移除后就变成了销毁状态。系统最倾向于回收处于这种状态的 Activity，以保证手机的内存充足。

### Activity的生存期

Activity类中定义了7个回调方法，覆盖了Activity生命周期的每一个环节，下面就来一一介绍这7个方法

- onCreate()。这个方法你已经看到过很多次了，我们在每个Activity中都重写了这个方法，它会在Activity第一次被创建的时候调用。你应该在这个方法中完成Activity的初始化操作，比如加载布局绑定事件等等
- onStart()。这个方法在Activity由不可见变为可见的时候调用
- onResume()。这个方法在Activity准备好和用户进行交互的时候调用。此时的Activity一定位于返回栈的栈顶，并且处于运行状态
- onPause()。这个方法在系统准备去启动或者恢复另一个Activity的时候调用。我们通常会在这个方法将消耗CPU的资源释放掉，以及保存一些关键数据，但这个方法的执行速度一定要快，不如会影响到新的栈顶Actiity的使用
- onStop()。这个方法在Activity完全不可见时候调用。它和onPause()方法的主要区别在于，如果启动新的Activity时一个对话框式的Activity，那么onPause()方法会得到执行，而onStop方法并不会执行
- onDestory()。这个方法在Activity被销毁之前调用，之后Activity的状态将变为销毁状态
- onRestart()。。这个方法在Activity由停止状态变为运行状态之前调用，也就是Activity 被重新启动了

以上7个方法中除了onRestart()方法，其他都是两两相对的，从而又可以将Activity分为以 下3种生存期。

完整生存期。Activity在onCreate()方法和onDestroy()方法之间所经历的就是完整生 存期。一般情况下，一个Activity会在onCreate()方法中完成各种初始化操作，而在 onDestroy()方法中完成释放内存的操作。

可见生存期。Activity在onStart()方法和onStop()方法之间所经历的就是可见生存 期。在可见生存期内，Activity对于用户总是可见的，即便有可能无法和用户进行交互。我 们可以通过这两个方法合理地管理那些对用户可见的资源。比如在onStart()方法中对资 源进行加载，而在onStop()方法中对资源进行释放，从而保证处于停止状态的Activity不 会占用过多内存。

前台生存期 。Activity在onResume()方法和onPause()方法之间所经历的就是前台生存 期。在前台生存期内，Activity总是处于运行状态，此时的Activity是可以和用户进行交互 的，我们平时看到和接触最多的就是这个状态下的Activity。

### 体验Activity的生命周期

讲了这么多理论知识，是时候进行实战了。下面我们将通过一个实例，让你可以更加直观地体 验Activity的生命周期。 这次我们不准备在ActivityTest这个项目的基础上修改了，而是新建一个项目。因此，首先关闭 ActivityTest项目，点击导航栏File→Close Project。然后新建一个ActivityLifeCycleTest项 目，新建项目的过程你应该已经非常清楚了，不需要我再进行赘述，这次我们允许Android Studio帮我们自动创建Activity和布局，这样可以省去不少工作，创建的Activity名和布局名都 使用默认值。 这样主Activity就创建完成了，我们还需要分别再创建两个子Activity——NormalActivity和 DialogActivity，下面一步步来实现。

右击com.example.activitylifecycletest包→New→Activity→Empty Activity，新建 NormalActivity，布局起名为normal_layout。然后使用同样的方式创建DialogActivity，布 局起名为dialog_layout

现在编辑normal_layout.xml文件，将里面的代码替换成如下内容：

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="vertical"
              android:layout_width="match_parent"
              android:layouot_height="match_parent">
    <TextView
              android:layout_width="match_parent"
              android:ayout_height="wrap_content"
              android:text="This is a normal activity"
              />
</LinearLayout>
```

在这个布局中，我们非常简单地使用了一个TextView，用于显示一行文字，在下一章中你将会 学到关于TextView的更多用法

然后编辑dialog_layout.xml文件，将里面的代码替换成如下内容：

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="vertacial"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              >
    <TextView
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:text="This is a dialog activity"
              />
</LinearLayout>
```

两个布局文件的代码几乎没有区别，只是显示的文字不同而已

其实从名字上就可以看出，这两个Activity一个是普通的Activity，一个是对话框式的 Activity。可是我们并没有修改Activity的任何代码，两个Activity的代码应该几乎是一模一样 的，那么是在哪里将Activity设成对话框式的呢？别着急，下面我们马上开始设置。修改 AndroidManifest.xml的标签的配置，如下所示：

```xml
<activity android:name=".DialogActivity"
          android:theme="@style/Theme.AppCompat.Dialog"> 
</activity>
<activity android:name=".NormalActivity">
</activity>
```

这里是两个Activity的注册代码，但是DialogActivity的代码有些不同，我们给它使用了一个 android:theme属性，用于给当前Activity指定主题，Android系统内置有很多主题可以选 择，当然我们也可以定制自己的主题，而这里的@style/Theme.AppCompat.Dialog则毫无 疑问是让DialogActivity使用对话框式的主题。

接下来我们修改activity_main.xml，重新定制主Activity的布局，将里面的代码替换成如下内 容

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:orientation="vertical" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent"> 
    <Button 
        android:id="@+id/startNormalActivity" 
        android:layout_width="match_parent" 
        android:layout_height="wrap_content" 
        android:text="Start NormalActivity" /> 
    <Button 
        android:id="@+id/startDialogActivity" 
        android:layout_width="match_parent" 
        android:layout_height="wrap_content" 
        android:text="Start DialogActivity" /> 
</LinearLayout> 
```

最后修改MainActivity中的代码，如下所示

```kotlin
class MainActivity:AppCompatActivity(){
    private val tag = "MainActivity"
    override fun onCreate(savedInstanceState)
    Log.d(tag,"onCreate")
    setContentView(R.layout.activity_main)
    val startNormalActivity:Button = findViewById(R.id.startNormalActivity)
    val startDialogActivity:Button = findViewById(R.id.startDialogActivity)
    startNormalActivity.setOnClickListener{
        val intent = Intent(this,NormalActivity::class.java)
        startActivity(intent)
    }
    startDialogActivity.setOnClickListener{
        val intent = Intent(this,DialogActivity::class.java)
        startActivity(intent)
    }
    override fun onStart(){
        super.onStart()
        Log.d(tag,"onStart")
    }
    override fun onResume(){
        super.onResume()
        Log.d(tag,"onResume")
    }
    override fun onPause(){
        super.onPause()
        Log.d(tag,"onPause")
    }
    override fun onStop(){
        super.onStop()
        Log.d(tag,"onStop")
    }
    override fun onDestroy(){
        super.onDestroy()
        Log.d(tag,"onDestroy")
    }
    override fun onRestart(){
        super.onRestart()
        Log.d(tag,"onRestart")
    }  
}
```

在onCreate()方法中，我们分别为两个按钮注册了点击事件，点击第一个按钮会启动 NormalActivity，点击第二个按钮会启动DialogActivity。然后在Activity的7个回调方法中分 别打印了一句话，这样就可以通过观察日志来更直观地理解Activity的生命周期。

### Activity被回收了怎么办

前面我们说过，当一个Activity进入了停止状态，是有可能被系统回收的。那么想象以下场景： 应用中有一个Activity A，用户在Activity A的基础上启动了Activity B，Activity A就进入了 停止状态，这个时候由于系统内存不足，将Activity A回收掉了，然后用户按下Back键返回 Activity A，会出现什么情况呢？其实还是会正常显示Activity A的，只不过这时并不会执行 onRestart()方法，而是会执行Activity A的onCreate()方法，因为Activity A在这种情况 下会被重新创建一次。 这样看上去好像一切正常，可是别忽略了一个重要问题：Activity A中是可能存在临时数据和状 态的。打个比方，MainActivity中如果有一个文本输入框，现在你输入了一段文字，然后启动 NormalActivity，这时MainActivity由于系统内存不足被回收掉，过了一会你又点击了Back键 回到MainActivity，你会发现刚刚输入的文字都没了，因为MainActivity被重新创建了。

如果我们的应用出现了这种情况，是会比较影响用户体验的，所以得想想办法解决这个问题。 其实，Activity中还提供了一个onSaveInstanceState()回调方法，这个方法可以保证在 Activity被回收之前一定会被调用，因此我们可以通过这个方法来解决问题

onSaveInstanceState()方法会携带一个Bundle类型的参数，Bundle提供了一系列的方法 用于保存数据，比如可以使用putString()方法保存字符串，使用putInt()方法保存整型数 据，以此类推。每个保存方法需要传入两个参数，第一个参数是键，用于后面从Bundle中取 值，第二个参数是真正要保存的内容

在MainActivity中添加如下代码就可以将临时数据进行保存了

```kotlin
override fun onSaveInstanceState(outSide:Bundle){
    super.onSaveInstanceState(outState)
    val tempData = "Something you just typed"
    outState.putString("data_key",tempData)
}
```

数据是已经保存下来了，那么我们应该在哪里进行恢复呢？细心的你也许早就发现，我们一直 使用的onCreate()方法其实也有一个Bundle类型的参数。这个参数在一般情况下都是 null，但是如果在Activity被系统回收之前，你通过onSaveInstanceState()方法保存数 据，这个参数就会带有之前保存的全部数据，我们只需要再通过相应的取值方法将数据取出即 可。

修改MainActivity的onCreate()方法，如下所示：

```kotlin
override fun onCreate(savedInstanceState:Bundle?){
    super.onCreate(savedInstanceState)
    Log.d(tag,"onCreate")
    setContentView(R.layout.activity_main)
    if(savedInstanceState!=null){
        val tempData = savadInstanceState.getString("data_key")
        Log.d(tag,"tempData is $tempData")
        ............
    }
}
```

## Activity的启动模式

Activity的启动模式对你来说应该是个全新的概念，在实际项目中我们应该根据特定的需求为每 个Activity指定恰当的启动模式。启动模式一共有4种，分别是standard、singleTop、 singleTask和singleInstance，可以在AndroidManifest.xml中通过给标签指定 android:launchMode属性来选择启动模式。下面我们来逐个进行学习。

### standard

tandard是Activity默认的启动模式，在不进行显式指定的情况下，所有Activity都会自动使用 这种启动模式。到目前为止，我们写过的所有Activity都是使用的standard模式。经过上一节 的学习，你已经知道了Android是使用返回栈来管理Activity的，在standard模式下，每当启 动一个新的Activity，它就会在返回栈中入栈，并处于栈顶的位置。对于使用standard模式的 Activity，系统不会在乎这个Activity是否已经在返回栈中存在，每次启动都会创建一个该 Activity的新实例。

### singleTop

可能在有些情况下，你会觉得standard模式不太合理。Activity明明已经在栈顶了，为什么再 次启动的时候还要创建一个新的Activity实例呢？别着急，这只是系统默认的一种启动模式而 已，你完全可以根据自己的需要进行修改，比如使用singleTop模式。当Activity的启动模式指 定为singleTop，在启动Activity时如果发现返回栈的栈顶已经是该Activity，则认为可以直接 使用它，不会再创建新的Activity实例。

我们还是通过实践来体会一下，修改AndroidManifest.xml中FirstActivity的启动模式，如下 所示

```xml
<activity
          addroid:name=".FirstActivity"
          android:launchMode="singleTop"
          android:label="This is FirstActivity"
          >
    <intent-filter>
        <action android:name="android.intent.action.MAIN"/>
        <category android:name="android.intent.category.LAUNCHER"/>
    </intent-filter>
</activity>
```

### singleTask

使用singleTop模式可以很好地解决重复创建栈顶Activity的问题，但是正如你在上一节所看到 的，如果该Activity并没有处于栈顶的位置，还是可能会创建多个Activity实例的。那么有没有 什么办法可以让某个Activity在整个应用程序的上下文中只存在一个实例呢？这就要借助 singleTask模式来实现了。当Activity的启动模式指定为singleTask，每次启动该Activity时， 系统首先会在返回栈中检查是否存在该Activity的实例，如果发现已经存在则直接使用该实例， 并把在这个Activity之上的所有其他Activity统统出栈，如果没有发现就会创建一个新的 Activity实例

### singleInstance

singleInstance模式应该算是4种启动模式中最特殊也最复杂的一个了，你也需要多花点工夫来 理解这个模式。不同于以上3种启动模式，指定为singleInstance模式的Activity会启用一个新 的返回栈来管理这个Activity（其实如果singleTask模式指定了不同的taskAffinity，也会启动 一个新的返回栈）

## Activity的最佳实践

### 知晓当前是在哪一个Activity

我们还是在ActivityTest项目的基础上修改，首先需要新建一个BaseActivity类。右击 com.example.activitytest包→New→Kotlin File/Class，在弹出的窗口中输入 BaseActivity，创建类型选择Class

注意，这里的BaseActivity和普通Activity的创建方式并不一样，因为我们不需要让 BaseActivity在AndroidManifest.xml中注册，所以选择创建一个普通的Kotlin类就可以 了。然后让BaseActivity继承自AppCompatActivity，并重写onCreate()方法，如下所 示

```kotlin
open class BaseActivity:AppCompatActivity(){
    override fun onCreate(savedInstanceState:Bundle?){
        super.onCreate(savedInstanceState)
        Log.d("BaseActivity",javaClass.simpleName)
    }
}
```

我们在onCreate()方法中加了一行日志，用于打印当前实例的类名。这里我要额外说明一 下，Kotlin中的javaClass表示获取当前实例的Class对象，相当于在Java中调用 getClass()方法；而Kotlin中的BaseActivity::class.java表示获取BaseActivity类的 Class对象，相当于在Java中调用BaseActivity.class。在上述代码中，我们先是获取了当 前实例的Class对象，然后再调用simpleName获取当前实例的类名。

接下来我们需要让BaseActivity成为ActivityTest项目中所有Activity的父类，为了使 BaseActivity可以被继承，我已经提前在类名的前面加上了open关键字。然后修改 FirstActivity、SecondActivity和ThirdActivity的继承结构，让它们不再继承自 AppCompatActivity，而是继承自BaseActivity。而由于BaseActivity又是继承自 AppCompatActivity的，所以项目中所有Activity的现有功能并不受影响，它们仍然继承了 Activity中的所有特性

现在每当我们进入一个Activity的界面，该Activity的类名就会被打印出来，这样我们就可以时 刻知晓当前界面对应的是哪一个Activity了。

### 随时随地退出程序

如果目前你手机的界面还停留在ThirdActivity，你会发现当前想退出程序是非常不方便的，需 要连按3次Back键才行。按Home键只是把程序挂起，并没有退出程序。如果我们的程序需要 注销或者退出的功能该怎么办呢？看来要有一个随时随地都能退出程序的方案才行。其实解决思路也很简单，只需要用一个专门的集合对所有的Activity进行管理就可以了。下面我 们就来实现一下。

```kotlin
object ActivityCollector{
    private val activities = ArrayList<Activity>()
    
    fun addActivity(activity:Activity){
        activities.add(activity)
    }
    
    fun removeActivity(activity:Activity){
        activities.remove(activity)
    }
    
    fun finishAll(){
        for(activity in activities){
            if(!activity.isFinishing){
                activity.finish()
            }
        }
        activities.clear()
    }
}
```

接下来修改BaseActivity中的代码，如下所示

```kotlin
open class BaseActivity:AppCompatActivity(){
    override fun onCreate(savedInstanceState:Bundle?){
        super.onCreate(savedInstanceState)
        Log.d("BaseActivity",javaClass.simpleName)
        ActivityCollector.addActivity(this)
    }
    
    override fun onDestroy(){
        super.onDestroy()
        ActivityCollector.removeActivity(this)
    }
}
```

在BaseActivity的onCreate()方法中调用了ActivityCollector的addActivity()方 法，表明将当前正在创建的Activity添加到集合里。然后在BaseActivity中重写 onDestroy()方法，并调用了ActivityCollector的removeActivity()方法，表明从集 合里移除一个马上要销毁的Activity

从此以后，不管你想在什么地方退出程序，只需要调用ActivityCollector.finishAll() 方法就可以了。例如在ThirdActivity界面想通过点击按钮直接退出程序，只需将代码改成如下 形式

```kotlin
class ThirdActivity:BaseActivity(){
    override fun onCreate(savedInstanceState:Bundle?){
        super.onCreate(savedInstanceState)
        Log.d("ThirdActivity","Task id is $taskId")
        setContentView(R.layout.third_layout)
        val button3:Button = findViewById(R.id.Button3)
        button3.setOnClickListener{
            ActivityColletor.finishAll()
        }        
    }
}
```

当然你还可以在销毁所有Activity的代码后面再加上杀掉当前进程的代码，以保证程序完全退 出，杀掉进程的代码如下所示

```kotlin
android.os.Process.killProcess(android.os.Process.myPid())
```

killProcess()方法用于杀掉一个进程，它接收一个进程id参数，我们可以通过myPid()方 法来获得当前程序的进程id。需要注意的是，killProcess()方法只能用于杀掉当前程序的 进程，不能用于杀掉其他程序

### 启动Activity的最佳方法

假设SecondActivity中需要用到两个非常重要的字符串参数，在启动SecondActivity的时候必 须传递过来，那么我们很容易会写出如下代码：

```kotlin
val intent = Intent(this,SecondActivity::class.java)
intent.putExtra("param1","data1")
intent.putExtra("param2","data2")
```

虽然这样写是完全正确的，但是在真正的项目开发中经常会出现对接的问题。比如 SecondActivity并不是由你开发的，但现在你负责开发的部分需要启动SecondActivity，而你 却不清楚启动SecondActivity需要传递哪些数据。这时无非就有两个办法：一个是你自己去阅 读SecondActivity中的代码，另一个是询问负责编写SecondActivity的同事。你会不会觉得很 麻烦呢？其实只需要换一种写法，就可以轻松解决上面的窘境。 修改SecondActivity中的代码，如下所示

```kotlin
class SecondActivity:BaseActivity(){
    compain object{
        fun actionStart(context:Context,data1:String,data2:String){
            val intent = Intent(context,SecondActivity::class.java)
            intent.putExtra("param1",data1)
            intent.putExtra("param2",data2)
            context.startActivity(intent)
        }
    }
}
```

在这里我们使用了一个新的语法结构companion object，并在companion object中定义 了一个actionStart()方法。之所以要这样写，是因为Kotlin规定，所有定义在companion object中的方法都可以使用类似于Java静态方法的形式调用。关于companion object的更 多内容，我会在本章的Kotlin课堂中进行讲解

接下来我们重点看actionStart()方法，在这个方法中完成了Intent的构建，另外所有 SecondActivity中需要的数据都是通过actionStart()方法的参数传递过来的，然后把它们 存储到Intent中，最后调用startActivity()方法启动SecondActivity。

这样写的好处在哪里呢？最重要的一点就是一目了然，SecondActivity所需要的数据在方法参 数中全部体现出来了，这样即使不用阅读SecondActivity中的代码，不去询问负责编写 SecondActivity的同事，你也可以非常清晰地知道启动SecondActivity需要传递哪些数据。另  外，这样写还简化了启动Activity的代码，现在只需要一行代码就可以启动SecondActivity， 如下所示

```kotlin
button1.setOnClickListener{
    SecondActivity.actionStart(this,"data1","data2")
}
```

## Kotlin课堂：标准函数和静态方法

### 标准函数with、run和apply

 Kotlin的标准函数指的是Standard.kt文件中定义的函数，任何Kotlin代码都可以自由地调用所 有的标准函数

下面我们从with函数开始学起。with函数接收两个参数：第一个参数可以是一个任意类型的对 象，第二个参数是一个Lambda表达式。with函数会在Lambda表达式中提供第一个参数对象 的上下文，并使用Lambda表达式中的最后一行代码作为返回值返回。示例代码如下：

```kotlin
val result = with(obj) { 
    // 
这里是obj的上下文 
    "value" // with函数的返回值 
} 
```

那么这个函数有什么作用呢？它可以在连续调用同一个对象的多个方法时让代码变得更加精 简，下面我们来看一个具体的例子。

比如有一个水果列表，现在我们想吃完所有水果，并将结果打印出来，就可以这样写

```kotlin
val list = listOf("Apple","Banana","Orange","Pear","Grape")
val builder = StringBuilder()
builder.append("Start eating fruits.\n")
for(fruit in list){
    builder.append(fruit).append("\n")
}
builder.append("Ate all fruits.")
val result = builder.toString()
println(result)
```

仔细观察上述代码，你会发现我们连续调用了很多次builder对象的方法。其实这个时候就可 以考虑使用with函数来让代码变得更加精简，如下所示：

```kotlin
val list = listOf("Apple","Banana","Orange","Pear","Grape")
val result = with(StringBuilder()){
    append("Start eating fruits.\n")
    for(fruit in list){
       append(fruit).append("\n")
    }
    append("Ate all fruits")
    toString
}
println(result)
```

这段代码乍一看可能有点迷惑性，其实很好理解。首先我们给with函数的第一个参数传入了一 个StringBuilder对象，那么接下来整个Lambda表达式的上下文就会是这个 StringBuilder对象。于是我们在Lambda表达式中就不用再像刚才那样调用 builder.append()和builder.toString()方法了，而是可以直接调用append()和 toString()方法。Lambda表达式的最后一行代码会作为with函数的返回值返回，最终我们 将结果打印出来。 这两段代码的执行结果是一模一样的，但是明显第二段代码的写法更加简洁一些，这就是with 函数的作用

下面我们再来学习另外一个常用的标准函数：run函数。run函数的用法和使用场景其实和 with函数是非常类似的，只是稍微做了一些语法改动而已。首先run函数通常不会直接调用， 而是要在某个对象的基础上调用；其次run函数只接收一个Lambda参数，并且会在Lambda表 达式中提供调用对象的上下文。其他方面和with函数是一样的，包括也会使用Lambda表达式 中的最后一行代码作为返回值返回。示例代码如下

```kotlin
val result = obj.run { 
    // 
这里是obj的上下文 
    "value" // run函数的返回值 
} 
```

那么现在我们就可以使用run函数来修改一下吃水果的这段代码，如下所示

```kotlin
val list = listOf("Apple","Banana","Orange","Pear","Grape")
val result = StringBuilder().run{
    append("Start eating fruits.\n")
    for(fruit in list){
        append(fruit).append("\n")
    }
    append("Ate all fruits")
    toSring()
}
println(result)
```

最后我们再来学习标准函数中的apply函数。apply函数和run函数也是极其类似的，都要在某 个对象上调用，并且只接收一个Lambda参数，也会在Lambda表达式中提供调用对象的上下 文，但是apply函数无法指定返回值，而是会自动返回调用对象本身。示例代码如下：

```kotlin
val result = obj.apply { 
     // 这里是obj的上下文 
} 
// result == obj 
```

那么现在我们再使用apply函数来修改一下吃水果的这段代码，如下所示

```kotlin
val list = listOf("Apple","Banana","Orange","Pear","Grape")
val result = StringBuilder().apply{
    append("Start eating fruits.\n")
    for(fruit in list){
        append(fruit).append("\n")
    }
}
```

注意这里的代码变化，由于apply函数无法指定返回值，只能返回调用对象本身，因此这里的 result实际上是一个StringBuilder对象，所以我们在最后打印的时候还要再调用它的 toString()方法才行。这段代码的执行结果和前面两段仍然是完全相同的，我就不再重复演 示了

回想一下刚刚在最佳实践环节编写的启动Activity的代码

```kotlin
val intent = Intent(context,SecnodActivity::class.java)
intent.putExtra("param1","data1")
intent.putExtra("param2","data2")
context.startActivity(intent)
```

这里每传递一个参数就要调用一次intent.putExtra()方法，如果要传递10个参数，那就得 调用10次。对于这种情况，我们就可以使用标准函数来对代码进行精简，如下所示：

```kotlin
val intent = Intent(context,SecondActivity::class.java).apply{
    putExtra("param1","data1")
    putExtra("param2","data2")
}
context.startActivity(intent)
```

可以看到，由于Lambda表达式中的上下文就是Intent对象，所以我们不再需要调用 intent.putExtra()方法，而是直接调用putExtra()方法就可以了。传递的参数越多，这 种写法的优势也就越明显

### 定义静态方法

像工具类这种功能，在Kotlin中就非常推荐使用单例类的方式来实现，比如上述的Util工具 类，如果使用Kotlin来实现的话就可以这样写

```kotlin
object Util{
    fun doAction(){
        println("do action")
    }
}
```

虽然这里的doAction()方法并不是静态方法，但是我们仍然可以使用Util.doAction()的 方式来调用，这就是单例类所带来的便利性。

不过，使用单例类的写法会将整个类中的所有方法全部变成类似于静态方法的调用方式，而如 果我们只是希望让类中的某一个方法变成静态方法的调用方式该怎么办呢？这个时候就可以使 用刚刚在最佳实践环节用到的companion object了，示例如下

```kotlin
class Util{
    fun doAction1(){
        println("do action1")
    }
    companion object{
        fun doAction2(){
            println("do action2")
        }
    }
}
```

然而如果你确确实实需要定义真正的静态方法， Kotlin仍然提供了两种实现方式：注解和顶层 方法。下面我们来逐个学习一下。

如果我们给单例类或companion object中的方 法加上@JvmStatic注解，那么Kotlin编译器就会将这些方法编译成真正的静态方法，如下所 示

```kotlin
class Util{
    fun doAction1(){
        println("do action1")
    }
    companion object{
        @JvmStatic
        fun doAction2(){
            println("do action2")
        }
    }
}
```

注意，@JvmStatic注解只能加在单例类或companion object中的方法上，如果你尝试加在 一个普通方法上，会直接提示语法错误。

再来看顶层方法，顶层方法指的是那些没有定义在任何类中的方法，比如我们在上一节中编写 的main()方法。Kotlin编译器会将所有的顶层方法全部编译成静态方法，因此只要你定义了一 个顶层方法，那么它就一定是静态方法

想要定义一个顶层方法，首先需要创建一个Kotlin文件。对着任意包名右击 → New → Kotlin File/Class，在弹出的对话框中输入文件名即可。注意创建类型要选择File，点击“OK”完成创建，这样刚刚的包名路径下就会出现一个Helper.kt文件。现在我们在这个文件 中定义的任何方法都会是顶层方法



# UI开发

## 常用控件的使用方法

### TextView

下面我们就来看一看TextView的更多用法，将activity_main.xml的代码改成如下所示：

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:orientation="vertical" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent"> 
    <TextView 
        android:id="@+id/textView" 
        android:layout_width="match_parent" 
        android:layout_height="wrap_content" 
        android:text="This is TextView"/> 
</LinearLayout> 
```

Android中所有的控件都具有这两个属 性，可选值有3种：match_parent、wrap_content和固定值。固 定值表示表示给控件指定一个固定的尺寸，单位一般用dp，这是一种屏幕密度无关的尺寸单 位，可以保证在不同分辨率的手机上显示效果尽可能地一致，如50 dp就是一个有效的固定值。

修改TextView的文字对 齐方式，如下所示

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:orientation="vertical" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent"> 
    <TextView 
        android:id="@+id/textView" 
        android:layout_width="match_parent" 
        android:layout_height="wrap_content"
        android:gravity="center"
        android:text="This is TextView"/> 
</LinearLayout> 
```

可选值有top、bottom、start、 end、center

另外，我们还可以对TextView中文字的颜色和大小进行修改，如下所示

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:orientation="vertical" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent"> 
    <TextView 
        android:id="@+id/textView" 
        android:layout_width="match_parent" 
        android:layout_height="wrap_content"
        android:gravity="center"
        android:textColor="#00ff00"
        android:textSize="24sp"
        android:text="This is TextView"/> 
</LinearLayout> 
```

### Button

它可配置的属性和TextView是差不多的，我们可以在 activity_main.xml中这样加入Button

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:orientation="vertical" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent"> 
    ... 
    <Button 
        android:id="@+id/button" 
        android:layout_width="match_parent" 
        android:layout_height="wrap_content" 
        android:text="Button" /> 
</LinearLayout>
```

如果你很细心的话，可能会发现我们在XML中指定按钮上的文字明明是Button，可是为什么界 面上显示的却是BUTTON呢？这是因为Android系统默认会将按钮上的英文字母全部转换成大 写，可能是认为按钮上的内容都比较重要吧。如果这不是你想要的效果，可以在XML中添加 android:textAllCaps="false"这个属性

接下来我们可以在MainActivity中为Button的点击事件注册一个监听器，如下所示

```kotlin
class MainActivity:AppCompatActivity(){
    override fun onCreate(savedInstanceState:Bundle?){
        super.onCreate(savedInstanceState)
        setContentVeiw(R.layout.activity_main)
        button.setOnClickListener{
            
        }
    }
}
```

除了使用函数式API的方式来注册监听器，也可以使用实现接口的方式来进行注册，代码如下所示

```kotlin
class MainActivity:AppCompatActivity(),View.OnClckListener{
    override fun onCreate(savedInstanceState:Bundle?){
        super.onCreate(savedInstanceState)
        setContentVew(R.layout.activity_main)
        button.setOnClickListener(this)
    }
    
    override fun onClick(v:View?){
        whne(v?.id){
            R.id.button->{
                
            }
        }
    }
}
```

这里我们让MainActivity实现了View.OnClickListener接口，并重写了onClick()方法， 然后在调用button的setOnClickListener()方法时将MainActivity的实例传了进去。这样 每当点击按钮时，就会执行onClick()方法中的代码了

### EditText

EditText是程序用于和用户进行交互的另一个重要控件，它允许用户在控件里输入和编辑内 容，并可以在程序中对这些内容进行处理。那我们来看一看如何 在界面上加入EditText吧，修改activity_main.xml中的代码，如下所示

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:orientation="vertical" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent"> 
    <EditText 
        android:id="@+id/editText" 
        android:layout_width="match_parent" 
        android:layout_height="wrap_content" 
        /> 
```

你可能平时会留意到，一些做得比较人性化的软件会在输入框里显示一些提示性的文字，一旦 用户输入了任何内容，这些提示性的文字就会消失。这种提示功能在Android里是非常容易实现 的，我们甚至不需要做任何逻辑控制，因为系统已经帮我们都处理好了。修改 activity_main.xml，如下所示：

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:orientation="vertical" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent"> 
    <EditText 
        android:id="@+id/editText" 
        android:layout_width="match_parent" 
        android:layout_height="wrap_content" 
        android:hint="Type something here" 
        /> 
</LinearLayout> 
```

不过，随着输入的内容不断增多，EditText会被不断地拉长。这是由于EditText的高度指定的是 wrap_content，因此它总能包含住里面的内容，但是当输入的内容过多时，界面就会变得非 常难看。我们可以使用android:maxLines属性来解决这个问题，修改activity_main.xml， 如下所示

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:orientation="vertical" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent"> 
    <EditText 
        android:id="@+id/editText" 
        android:layout_width="match_parent" 
        android:layout_height="wrap_content" 
        android:hint="Type something here" 
        android:maxLines="2" 
        /> 
</LinearLayout> 
```

点击按钮以弹出EditText中的消息

```kotlin
class MainActivity:AppCompatActivity(),View.OnclickListener{
    lateinit var editText:EditText
    override fun onCreate(savedInstanceState:Bundle?){
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        val button:Button=findViewById(R.id.button)
        editText=findViewById(R.id.editText)
        button.setOnClickListener(this)
    }
    override fun onClick(v:View?){
        when(v?.id){
            R.id.button->{
                var inputText = editText.text.toString()
                Toast.makeText(this,inputText,Toast.LENGTH_SHORT).show()
            }
        }
    }
}
```

### ImageView

ImageView是用于在界面上展示图片的一个控件，它可以让我们的程序界面变得更加丰富多彩。图片通常是放在以drawable开头的目录下的，并 且要带上具体的分辨率。现在最主流的手机屏幕分辨率大多是xxhdpi的，所以我们在res目录下 再新建一个drawable-xxhdpi目录，然后将事先准备好的两张图片img_1.png和img_2.png复 制到该目录当中

接下来修改activity_main.xml，如下所示

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <TextView
        android:id="@+id/textView"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:gravity="center"
        android:text="This is TextView"
        android:textColor="#00ff00"
        android:textSize="24sp"/>
    <Button
        android:id="@+id/button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Button"
        android:textAllCaps="false"/>
    <EditText
        android:id="@+id/editText"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="Type something here"
        android:maxLines="2"/>
    <ImageView
        android:id="@+id/imageView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@drwaable/img_1"/>

</LinearLayout>
```

用android:src属性给ImageView指定了一张图片。由于图片的宽和高都 是未知的，所以将ImageView的宽和高都设定为wrap_content，这样就保证了不管图片的尺 寸是多少，都可以完整地展示出来

我们还可以在程序中通过代码动态地更改ImageView中的图片，修改MainActivity的代码，如 下所示

```kotlin
class MainActivity : AppCompatActivity(),View.OnClickListener{
    ....
    override fun onClick(v:View?){
        when(v?.id){
            R.id.button->{
                imageViw.setImageResource(R.drwaable.img_2)
            }
        }
    }
}
```

### ProgressBar

ProgressBar用于在界面上显示一个进度条，表示我们的程序正在加载一些数据。它的用法也 非常简单，修改activity_main.xml中的代码，如下所示

```xml
<LinerLayout xmlns:android="http://schemas.android.com/apk/res/android"
             android:orientatio="vertical"
             android:layout_width="match_parent"
             android:layout_height="match_parent">
    <ProgerssBar android:id="@id/progressBar"
                 android:layout_width="match_parent"
                 android:layout_height="wrap_content"/>
</LinerLayout>
```

android:visibility进行指定，可选值有3种：visible、invisible和gone。visible 表示控件是可见的，这个值是默认值，不指定android:visibility时，控件都是可见的。 invisible表示控件不可见，但是它仍然占据着原来的位置和大小，可以理解成控件变成透明 状态了。gone则表示控件不仅不可见，而且不再占用任何屏幕空间。我们可以通过代码来设置 控件的可见性，使用的是setVisibility()方法，允许传入View.VISIBLE、 View.INVISIBLE和View.GONE这3种值

```kotlin
class MainActivity:AppCompatActivity(),View.OnClickListener{
    ...
    override fun onClick(v:View?){
        when(v?.id){
            R.id.button->{
                if(progressBar.visibility == View.VISIBLE){
                    progerssBar.visibility = View.GONE
                }else{
                    progressBar.visibility = View.VISIBLE
                }
            }
        }
    }
}
```

另外，我们还可以给ProgressBar指定不同的样式，刚刚是圆形进度条，通过style属性可以将 它指定成水平进度条，修改activity_main.xml中的代码，如下所示：

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:orientation="vertical" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent"> 
 
    ... 
 
    <ProgressBar 
        android:id="@+id/progressBar" 
        android:layout_width="match_parent" 
        android:layout_height="wrap_content" 
        style="?android:attr/progressBarStyleHorizontal" 
        android:max="100" 
        /> 
 
</LinearLayout> 
```

指定成水平进度条后，我们还可以通过android:max属性给进度条设置一个最大值，然后在代 码中动态地更改进度条的进度。修改MainActivity中的代码，如下所示

```kotlin
class MainActivity : AppCompatActivity(), View.OnClickListener { 
 
    ... 
 
    override fun onClick(v: View?) { 
        when (v?.id) { 
            R.id.button -> { 
                progressBar.progress = progressBar.progress + 10 
            } 
        } 
    } 
} 
```

### AlertDialog

AlertDialog可以在当前界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够 屏蔽其他控件的交互能力，因此AlertDialog一般用于提示一些非常重要的内容或者警告信息

比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。下面我们来学习一下它的用 法，修改MainActivity中的代码，如下所示

```kotlin
class MainActivity:AppCOmpatActivity(),View.onClickListener{
    ...
    override fun onClick(v:View?){
        when(v?.id){
            R.id.button->{
                AlertDialog.Builder(this).apply{
                    setTitle("This is Dialog")
                    setMessage("Something important.")
                    setCancelable(false)
                    setPostiviButton("OK"){dialog,which->}
                    setNegativeButton("Cancel"){dialog,which->}
                    show()                    
                }
            }
        }
    }
}
```

## 详解3种基本布局

### LinearLayot

下面来看android:layout_gravity属性，它和我们上一节中学到的android:gravity属 性看起来有些相似，这两个属性有什么区别呢？其实从名字就可以看出，android:gravity 用于指定文字在控件中的对齐方式，而android:layout_gravity用于指定控件在布局中的 对齐方式。android:layout_gravity的可选值和android:gravity差不多，但是需要注 意，当LinearLayout的排列方向是horizontal时，只有垂直方向上的对齐方式才会生效。因 为此时水平方向上的长度是不固定的，每添加一个控件，水平方向上的长度都会改变，因而无 法指定该方向上的对齐方式。同样的道理，当LinearLayout的排列方向是vertical时，只有 水平方向上的对齐方式才会生效。修改activity_main.xml中的代码，如下所示：

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:orientation="horizontal" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent"> 
    <Button 
        android:id="@+id/button1" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_gravity="top" 
        android:text="Button 1" /> 
    <Button 
        android:id="@+id/button2" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_gravity="center_vertical" 
        android:text="Button 2" /> 
    <Button 
        android:id="@+id/button3" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_gravity="bottom" 
        android:text="Button 3" /> 
</LinearLayout> 
```

接下来我们学习LinearLayout中的另一个重要属性——android:layout_weight。这个属 性允许我们使用比例的方式来指定控件的大小，它在手机屏幕的适配性方面可以起到非常重要 的作用。比如，我们正在编写一个消息发送界面，需要一个文本编辑框和一个发送按钮，修改 activity_main.xml中的代码，如下所示：

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:orientation="horizontal" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent"> 
    <EditText 
        android:id="@+id/input_message" 
        android:layout_width="0dp" 
        android:layout_height="wrap_content" 
        android:layout_weight="1" 
        android:hint="Type something" 
        /> 
    <Button 
        android:id="@+id/send" 
        android:layout_width="0dp" 
        android:layout_height="wrap_content" 
        android:layout_weight="1" 
        android:text="Send" 
        /> 
</LinearLayout>
```

你会发现，这里竟然将EditText和Button的宽度都指定成了0 dp，这样文本编辑框和按钮还能 显示出来吗？不用担心，由于我们使用了android:layout_weight属性，此时控件的宽度就 不应该再由android:layout_width来决定了，这里指定成0 dp是一种比较规范的写法。

然后在EditText和Button里将android:layout_weight属性的值指定为1，这表示EditText 和Button将在水平方向平分宽度

为什么将android:layout_weight属性的值同时指定为1就会平分屏幕宽度呢？其实原理很 简单，系统会先把LinearLayout下所有控件指定的layout_weight值相加，得到一个总值， 然后每个控件所占大小的比例就是用该控件的layout_weight值除以刚才算出的总值。因此如 果想让EditText占据屏幕宽度的3/5，Button占据屏幕宽度的2/5，只需要将EditText的 layout_ weight改成3，Button的layout_weight改成2就可以了

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:orientation="horizontal" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent"> 
    <EditText 
        android:id="@+id/input_message" 
        android:layout_width="0dp" 
        android:layout_height="wrap_content" 
        android:layout_weight="1" 
        android:hint="Type something" 
        /> 
    <Button 
        android:id="@+id/send" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:text="Send" 
        /> 
</LinearLayout>
```

这里我们仅指定了EditText的android:layout_weight属性，并将Button的宽度改回了 wrap_content。这表示Button的宽度仍然按照wrap_content来计算，而EditText则会占满 屏幕所有的剩余空间。使用这种方式编写的界面，不仅可以适配各种屏幕，而且看起来也更加 舒服。

### RelativeLayout

```xml
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent"> 
 
    <Button 
        android:id="@+id/button1" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_alignParentLeft="true" 
        android:layout_alignParentTop="true" 
        android:text="Button 1" /> 
 
    <Button 
        android:id="@+id/button2" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_alignParentRight="true" 
        android:layout_alignParentTop="true" 
        android:text="Button 2" /> 
 
    <Button 
        android:id="@+id/button3" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_centerInParent="true" 
        android:text="Button 3" /> 
 
    <Button 
        android:id="@+id/button4" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_alignParentBottom="true" 
        android:layout_alignParentLeft="true" 
        android:text="Button 4" /> 
 
    <Button 
        android:id="@+id/button5" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_alignParentBottom="true" 
        android:layout_alignParentRight="true" 
        android:text="Button 5" /> 
 
</RelativeLayout>
```

以上代码不需要做过多解释，因为实在是太好理解了。我们让Button 1和父布局的左上角对 齐，Button 2和父布局的右上角对齐，Button 3居中显示，Button 4和父布局的左下角对齐， Button 5和父布局的右下角对齐。虽然android:layout_alignParentLeft、 android:layout_alignParentTop、android:layout_alignParentRight、 android:layout_alignParentBottom、android:layout_centerInParent这几个属 性我们之前都没接触过，可是它们的名字已经完全说明了它们的作用。

上面例子中的每个控件都是相对于父布局进行定位的，那控件可不可以相对于控件进行定位 呢？当然是可以的，修改activity_main.xml中的代码，如下所示：

```xml
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent"> 
 
    <Button 
        android:id="@+id/button3" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_centerInParent="true" 
        android:text="Button 3" /> 
 
    <Button 
        android:id="@+id/button1" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_above="@id/button3" 
        android:layout_toLeftOf="@id/button3" 
        android:text="Button 1" /> 
 
    <Button 
        android:id="@+id/button2" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_above="@id/button3" 
        android:layout_toRightOf="@id/button3" 
        android:text="Button 2" /> 
 
    <Button 
        android:id="@+id/button4" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_below="@id/button3" 
        android:layout_toLeftOf="@id/button3" 
        android:text="Button 4" /> 
 
    <Button 
        android:id="@+id/button5" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_below="@id/button3" 
        android:layout_toRightOf="@id/button3" 
        android:text="Button 5" /> 
 
</RelativeLayout>
```

RelativeLayout中还有另外一组相对于控件进行定位的属性，android:layout_alignLeft 表示让一个控件的左边缘和另一个控件的左边缘对齐，android:layout_alignRight表示 让一个控件的右边缘和另一个控件的右边缘对齐。此外，还有android:layout_alignTop和 android:layout_alignBottom，道理都是一样的

### FrameLayout

FrameLayout又称作帧布局，它相比于前面两种布局就简单太多了，因此它的应用场景少了很 多。这种布局没有丰富的定位方式，所有的控件都会默认摆放在布局的左上角。让我们通过例子来看一看吧，修改activity_main.xml中的代码，如下所示：

```xml
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent"> 
    <TextView 
        android:id="@+id/textView" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:text="This is TextView" 
        /> 
    <Button 
        android:id="@+id/button" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:text="Button" 
        /> 
</FrameLayout> 
```

可以看到，文字和按钮都位于布局的左上角。由于Button是在TextView之后添加的，因此按钮 压在了文字的上面

当然，除了这种默认效果之外，我们还可以使用layout_gravity属性来指定控件在布局中的 对齐方式，这和LinearLayout中的用法是相似的。修改activity_main.xml中的代码，如下所 示

```xml
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent"> 
    <TextView 
        android:id="@+id/textView" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_gravity="left" 
        android:text="This is TextView" 
        /> 
    <Button 
        android:id="@+id/button" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_gravity="right" 
        android:text="Button" 
        /> 
</FrameLayout>
```

## 系统控件不够用？创建自定义控件

我们所用的所有控件都是直接或间接继承自View的，所用的所有布局都是直接或间 接继承自ViewGroup的。View是Android中最基本的一种UI组件，它可以在屏幕上绘制一块矩 形区域，并能响应这块区域的各种事件，因此，我们使用的各种控件其实就是在View的基础上 又添加了各自特有的功能。而ViewGroup则是一种特殊的View，它可以包含很多子View和子 ViewGroup，是一个用于放置控件和布局的容器。

### 引入布局

如果在每个Activity的布局中都编 写一遍同样的标题栏代码，明显就会导致代码的大量重复。这时我们就可以使用引入布局的方 式来解决这个问题，在layout目录下新建一个title.xml布局，代码如下所示：

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:layout_width="match_parent" 
    android:layout_height="wrap_content" 
    android:background="@drawable/title_bg"> 
 
    <Button 
        android:id="@+id/titleBack" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_gravity="center" 
        android:layout_margin="5dp" 
        android:background="@drawable/back_bg" 
        android:text="Back" 
        android:textColor="#fff"/> 
 
    <TextView 
        android:id="@+id/titleText" 
        android:layout_width="0dp" 
        android:layout_height="wrap_content" 
        android:layout_gravity="center" 
        android:layout_weight="1" 
        android:gravity="center" 
        android:text="Title Text" 
        android:textColor="#fff" 
        android:textSize="24sp" /> 
 
    <Button 
        android:id="@+id/titleEdit" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_gravity="center" 
        android:layout_margin="5dp" 
        android:background="@drawable/edit_bg" 
        android:text="Edit" 
        android:textColor="#fff" /> 
 
</LinearLayout>
```

现在标题栏布局已经编写完成了，剩下的就是如何在程序中使用这个标题栏了，修改 activity_main.xml中的代码，如下所示

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent" > 
    <include layout="@layout/title"/>
</LinearLayout> 
```

最后别忘了在MainActivity中将系统自带的标题栏隐藏掉，代码如下所示

```kotlin
class MainActivity : AppCompatActivity() { 
    override fun onCreate(savedInstanceState: Bundle?) { 
        super.onCreate(savedInstanceState) 
        setContentView(R.layout.activity_main) 
        supportActionBar?.hide() 
    } 
} 
```

### 创建自定义控件

引入布局的技巧确实解决了重复编写布局代码的问题，但是如果布局中有一些控件要求能够响 应事件，我们还是需要在每个Activity中为这些控件单独编写一次事件注册的代码。比如标题栏 中的返回按钮，其实不管是在哪一个Activity中，这个按钮的功能都是相同的，即销毁当前 Activity。而如果在每一个Activity中都需要重新注册一遍返回按钮的点击事件，无疑会增加很 多重复代码，这种情况最好是使用自定义控件的方式来解决

新建TitleLayout继承自LinearLayout，让它成为我们自定义的标题栏控件，代码如下所示

```kotlin
class TitleLayout(context:Context,attrs:AttributeSet):LinerLayout(context,attrs){
    init{
        LayoutInflater.from(context).inflate(R.layout.title,this)
    }
}
```

这里我们在TitleLayout的主构造函数中声明了Context和AttributeSet这两个参数，在布局中 引入TitleLayout控件时就会调用这个构造函数。然后在init结构体中需要对标题栏布局进行动 态加载，这就要借助LayoutInflater来实现了。通过LayoutInflater的from()方法可以构建出 一个LayoutInflater对象，然后调用inflate()方法就可以动态加载一个布局文件。 inflate()方法接收两个参数：第一个参数是要加载的布局文件的id，这里我们传入 R.layout.title；第二个参数是给加载好的布局再添加一个父布局，这里我们想要指定为 TitleLayout，于是直接传入this。

现在自定义控件已经创建好了，接下来我们需要在布局文件中添加这个自定义控件，修改 activity_main.xml中的代码，如下所示：

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent" > 
    <com.example.uicustomviews.TitleLayout 
        android:layout_width="match_parent" 
        android:layout_height="wrap_content" /> 
</LinearLayout> 
```

添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候，我们 需要指明控件的完整类名，包名在这里是不可以省略的。

下面我们尝试为标题栏中的按钮注册点击事件，修改TitleLayout中的代码，如下所示

```kotlin
class TitleLayout(context: Context, attrs: AttributeSet) : LinearLayout(context, attrs) {  
    init { 
        LayoutInflater.from(context).inflate(R.layout.title, this) 
        titleBack.setOnClickListener { 
            val activity = context as Activity 
            activity.finish() 
        } 
        titleEdit.setOnClickListener { 
            Toast.makeText(context, "You clicked Edit button", Toast.LENGTH_SHORT).show() 
        } 
    } 
} 
```

注意，TitleLayout中接收的context参数实际上是一个Activity的实例，在返回按钮的点击事 件里，我们要先将它转换成Activity类型，然后再调用finish()方法销毁当前的Activity。 Kotlin中的类型强制转换使用的关键字是as，由于是第一次用到，所以这里单独讲解一下

### ListView

### ListView的简单使用方法

首先新建一个ListViewTest项目，并让Android Studio自动帮我们创建好Activity。然后修改 activity_main.xml中的代码，如下所示：

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent"> 
 
    <ListView 
        android:id="@+id/listView" 
        android:layout_width="match_parent" 
        android:layout_height="match_parent" /> 
 
</LinearLayout>
```

接下来修改MainActivity中的代码，如下所示：

```kotlin
class MainActivity : AppCompatActivity() { 
 
    private val data = listOf("Apple", "Banana", "Orange", "Watermelon", 
        "Pear", "Grape", "Pineapple", "Strawberry", "Cherry", "Mango", 
        "Apple", "Banana", "Orange", "Watermelon", "Pear", "Grape", 
        "Pineapple", "Strawberry", "Cherry", "Mango") 
 
    override fun onCreate(savedInstanceState: Bundle?) { 
        super.onCreate(savedInstanceState) 
        setContentView(R.layout.activity_main) 
        val adapter = ArrayAdapter<String>(this,android.R.layout.simple_list_item_1,data) 
        listView.adapter = adapter 
    } 
 
```

集合中的数据是无法直接传递给ListView的，我们还需要借助适配器来完成。Android 中提供了很多适配器的实现类，其中我认为最好用的就是ArrayAdapter。它可以通过泛型来指 定要适配的数据类型，然后在构造函数中把要适配的数据传入。ArrayAdapter有多个构造函数 的重载，你应该根据实际情况选择最合适的一种。由于我们这里提供的数据都是字符串，因此 将ArrayAdapter的泛型指定为String，然后在ArrayAdapter的构造函数中依次传入Activity 的实例、ListView子项布局的id，以及数据源。注意，我们使用了 android.R.layout.simple_list_item_1作为ListView子项布局的id，这是一个 Android内置的布局文件，里面只有一个TextView，可用于简单地显示一段文本。这样适配器 对象就构建好了

最后，还需要调用ListView的setAdapter()方法，将构建好的适配器对象传递进去，这样 ListView和数据之间的关联就建立完成了。

### 定制ListView 的界面

接着定义一个实体类，作为ListView适配器的适配类型。新建Fruit类，代码如下所示：

```kotlin
class Fruit(val name:String,val imageId:Int){
    
}
```

Fruit类中只有两个字段：name表示水果的名字，imageId表示水果对应图片的资源id。

然后需要为ListView的子项指定一个我们自定义的布局，在layout目录下新建 fruit_item.xml，代码如下所示：

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:layout_width="match_parent" 
    android:layout_height="60dp"> 
    <ImageView 
        android:id="@+id/fruitImage" 
        android:layout_width="40dp" 
        android:layout_height="40dp" 
        android:layout_gravity="center_vertical" 
        android:layout_marginLeft="10dp"/> 
    <TextView 
        android:id="@+id/fruitName" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_gravity="center_vertical" 
        android:layout_marginLeft="10dp" /> 
</LinearLayout> 
```

在这个布局中，我们定义了一个ImageView用于显示水果的图片，又定义了一个TextView用于 显示水果的名称，并让ImageView和TextView都在垂直方向上居中显示。

接下来需要创建一个自定义的适配器，这个适配器继承自ArrayAdapter，并将泛型指定为 Fruit类。新建类FruitAdapter，代码如下所示：

```kotlin
class FruitAdapter(activity:Activity:,val resourceId:int,data:List<Fruit>):
		ArrayAdapter<Fruint>(activity,resuorceId,data){
            override fun getView(position:Int,convertView:View?,parent:ViewGroup):View{
                val view = LayoutInflater.from(context).inflate(resourceId,parent,false)
                val fruitImage:ImageView = view.findViewById(R.id.fruitImage)
                val fruitName:TextView=view.findViewById(R.id.fruitName)
                var fruit = getItem(position)
                if(fruit!=null){
                    fruitImage.setImageResource(fruit.imageId);
                    fruitName.text=fruit.name
                }
                return view
            }
        }
```

FruitAdapter定义了一个主构造函数，用于将Activity的实例、ListView子项布局的id和数 据源传递进来。另外又重写了getView()方法，这个方法在每个子项被滚动到屏幕内的时候会 被调用。

在getView()方法中，首先使用LayoutInflater来为这个子项加载我们传入的布局。 LayoutInflater的inflate()方法接收3个参数，前两个参数我们已经知道是什么意思了， 第三个参数指定成false，表示只让我们在父布局中声明的layout属性生效，但不会为这个 View添加父布局。因为一旦View有了父布局之后，它就不能再添加到ListView中了。如果你现 在还不能理解这段话的含义，也没关系，只需要知道这是ListView中的标准写法就可以了，当 你以后对View理解得更加深刻的时候，再来读这段话就没有问题了

我们继续往下看，接下来调用View的findViewById()方法分别获取到ImageView和 TextView的实例，然后通过getItem()方法得到当前项的Fruit实例，并分别调用它们的 setImageResource()和setText()方法设置显示的图片和文字，最后将布局返回，这样我 们自定义的适配器就完成了。

最后修改MainActivity中的代码，如下所示

```kotlin
class MainActivity : AppCompatActivity(){
    private val fruitLsit = ArrayList<Fruit>()
    
    override fun onCreate(savedInstanceState:BUndle?){
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        initFruits()
        val adapter = FruitAdaper(this,R.layout.fruit_item,fruitList)
        listView.adapter = adapter     
    }
    private fun initFruits() { 
        repeat(2) { 
            fruitList.add(Fruit("Apple", R.drawable.apple_pic)) 
            fruitList.add(Fruit("Banana", R.drawable.banana_pic)) 
            fruitList.add(Fruit("Orange", R.drawable.orange_pic)) 
            fruitList.add(Fruit("Watermelon", R.drawable.watermelon_pic)) 
            fruitList.add(Fruit("Pear", R.drawable.pear_pic)) 
            fruitList.add(Fruit("Grape", R.drawable.grape_pic)) 
            fruitList.add(Fruit("Pineapple", R.drawable.pineapple_pic)) 
            fruitList.add(Fruit("Strawberry", R.drawable.strawberry_pic)) 
            fruitList.add(Fruit("Cherry", R.drawable.cherry_pic)) 
            fruitList.add(Fruit("Mango", R.drawable.mango_pic)) 
        }
}
```

可以看到，这里添加了一个initFruits()方法，用于初始化所有的水果数据。在Fruit类的 构造函数中将水果的名字和对应的图片id传入，然后把创建好的对象添加到水果列表中。另外， 我们使用了一个repeat函数将所有的水果数据添加了两遍，这是因为如果只添加一遍的话，数 据量还不足以充满整个屏幕。repeat函数是Kotlin中另外一个非常常用的标准函数，它允许你 传入一个数值n，然后会把Lambda表达式中的内容执行n遍。接着在onCreate()方法中创建 了FruitAdapter对象，并将它作为适配器传递给ListView，这样定制ListView界面的任务就 完成了

### 提升ListView 的运行效率

之所以说ListView这个控件很难用，是因为它有很多细节可以优化，其中运行效率就是很重要 的一点。目前我们ListView的运行效率是很低的，因为在FruitAdapter的getView()方法 中，每次都将布局重新加载了一遍，当ListView快速滚动的时候，这就会成为性能的瓶颈。

仔细观察你会发现，getView()方法中还有一个convertView参数，这个参数用于将之前加 载好的布局进行缓存，以便之后进行重用，我们可以借助这个参数来进行性能优化。修改 FruitAdapter中的代码，如下所示：

```kotlin
class FruitAdapter(activity:Activity,val resuorceId:Int,data:List<Fruit>) :
		ArrayAdapter<Fruit>(activity,resourceId,data){
            override fun getView(position: Int,convertView:View?,parent:ViewGroup):View{
                val view:View
                if(convertView == null){
                    view = LayoutInflater.from(context).inflate(resourceId,parent,false)
                }else{
                    view = convertView
                }
                var fruitImage:ImageView = view.findViewById(R.id.fruitImage)
                var fruitName:TextView = view.findVIew
                fruit = getItem(position)
                if(fruit!=null){
                    fruitImage.setImageResource(fruit.imageId)
                    fruitName.text = fruit.name
                }
                return view
            }
        }
```

可以看到，现在我们在getView()方法中进行了判断：如果convertView为null，则使用 LayoutInflater去加载布局；如果不为null，则直接对convertView进行重用。这样就大 大提高了ListView的运行效率，在快速滚动的时候可以表现出更好的性能。

不过，目前我们的这份代码还是可以继续优化的，虽然现在已经不会再重复去加载布局，但是 每次在getView()方法中仍然会调用View的findViewById()方法来获取一次控件的实例。 我们可以借助一个ViewHolder来对这部分性能进行优化，修改FruitAdapter中的代码，如 下所示

```kotlin
class FruitAdapter(activity:Activity,val resourceId:Int,data:List<Fruit>):
		ArrayAdapter<Fruit>(activity,resourceId,data){
            inner class ViewHolder(val fruitImage:ImageView,val fruitName:TextView)
            
            override fun getView(position:Int,convertView:View?,parent:ViewGroup):View{
                val view:View
                val viewHolder:ViewHolder
                if(convertView==null){
                    view = LayoutInflater.from(context).inflate(resourceId,parent,false)
                    val fruitImage:ImageView = view.findViewById(R.id.fruitImage)
                    val fruitName :TextVIew = view.findViewById(R.id.fruitName)
                    viewHolder = ViewHolder(fruitImage,fruitName)
                    view.tag = viewHolder
                }else{
                    view = convertView
                    viewHolder = view.tag as ViewHolder
                }
                
                val fruit = getItem(position)
                if(fruit !=null){
                    viewHolder.fruitImage.setImageResource(fruit.imageId)
                    viewHolder.fruitName.text = fruit.name
                }
                return view
            }
        }
```

我们新增了一个内部类ViewHolder，用于对ImageView和TextView的控件实例进行缓存， Kotlin中使用inner class关键字来定义内部类。当convertView为null的时候，创建一个 ViewHolder对象，并将控件的实例存放在ViewHolder里，然后调用View的setTag()方 法，将ViewHolder对象存储在View中。当convertView不为null的时候，则调用View的 getTag()方法，把ViewHolder重新取出。这样所有控件的实例都缓存在了ViewHolder里， 就没有必要每次都通过findViewById()方法来获取控件实例了。

### ListView的点击事件

话说回来，ListView的滚动毕竟只是满足了我们视觉上的效果，可是如果ListView中的子项不 能点击的话，这个控件就没有什么实际的用途了。因此，本小节我们就来学习一下ListView如 何才能响应用户的点击事件

修改MainActivity中的代码，如下所示

```kotlin
class MainActivity:AppComPatActivity(){
    private val fruitList = ArrayList<Fruit>()
    override fun onCreate(savedInstanceState:Bundle?){
        super.onCreate(savedInstanceState)
        setContentView(savedInstanceState)
        initFruits()
        val adapter = FruitAdappter(this,R.layout.fruit_item,fruitLis)
        listView.adapter = adapter
        listView.setOnItemClickListener{parent,view,position,id->
                                       vla fruit = fruitList[positon]
                                       Toast.maktText(this,fruit.name,Toast.LENGTH_SHORT).show()}
    }
}
```

可以看到，我们使用setOnItemClickListener()方法为ListView注册了一个监听器，当用 户点击了ListView中的任何一个子项时，就会回调到Lambda表达式中。这里我们可以通过 position参数判断用户点击的是哪一个子项，然后获取到相应的水果，并通过Toast将水果的 名字显示出来

另外你会发现，虽然这里我们必须在Lambda表达式中声明4个参数，但实际上却只用到了 position这一个参数而已。针对这种情况，Kotlin允许我们将没有用到的参数使用下划线来替 代，因此下面这种写法也是合法且更加推荐的

```kotlin
listView.setOnItemClickListener { _, _, position, _ -> 
    val fruit = fruitList[position] 
    Toast.makeText(this, fruit.name, Toast.LENGTH_SHORT).show() 
} 
```

## RecyclerView

Android提供了一个更强大的滚动控件——RecyclerView。它可以说是一个增强版的 ListView，不仅可以轻松实现和ListView同样的效果，还优化了ListView存在的各种不足之 处。

### RecyclerView的基本用法

打开app/build.gradle文件，在dependencies闭包中添加如下内容：

```xnl
dependencies { 
    implementation fileTree(dir: 'libs', include: ['*.jar']) 
    implementation"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version" 
    implementation 'androidx.appcompat:appcompat:1.0.2' 
    implementation 'androidx.core:core-ktx:1.0.2' 
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3' 
    implementation 'androidx.recyclerview:recyclerview:1.0.0' 
    testImplementation 'junit:junit:4.12' 
    androidTestImplementation 'androidx.test:runner:1.1.1' 
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.1.1' 
} 
```

接下来修改activity_main.xml中的代码，如下所示

```xml
<><LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent"> 
 
    <androidx.recyclerview.widget.RecyclerView 
        android:id="@+id/recyclerView" 
        android:layout_width="match_parent" 
        android:layout_height="match_parent" /> 
 
</LinearLayout>
```

接下来需要为RecyclerView准备一个适配器，新建FruitAdapter类，让这个适配器继承自 RecyclerView.Adapter，并将泛型指定为FruitAdapter.ViewHolder。其中， ViewHolder是我们在FruitAdapter中定义的一个内部类，代码如下所示

```kotlin
class FruitAdapter(val fruitList:List<Fruit>):
		RecyclerView.Adapter<FruitAdapter.ViewHolder>(){
            inner class ViewHolder(view:View):RecycleView.ViewHolder(view){
                val fruitImage:ImageIvew = view.findViewById(R.id.fruitImage)
                val fruitName:TextView = view.findViewById(R.id.fruirName)
            }
            
            override fun onCreateViewHolder(parent:ViewGroup,viewType:Int):ViewHolder{
                val view = LayoutInflater.from(parent.context).inflate(R.layout.fruit_item,parent,false)
                return ViewHolder(view)
            }
            
            override fun onBindViewHolder(holder:ViewHolder,position:Int){
                val fruit = fruitList[position]
                holder.fruitImage.setImageResource(fruit.imageId)
                holder.fruitName.text = fruit.name
            }
            
            override fun getItemCount() = fruitList.size
        }
```

这是RecyclerView适配器标准的写法，虽然看上去好像多了好几个方法，但其实它比ListView 的适配器要更容易理解。这里我们首先定义了一个内部类ViewHolder，它要继承自 RecyclerView.ViewHolder。然后ViewHolder的主构造函数中要传入一个View参数，这 个参数通常就是RecyclerView子项的最外层布局，那么我们就可以通过findViewById()方 法来获取布局中ImageView和TextView的实例了。

FruitAdapter中也有一个主构造函数，它用于把要展示的数据源传进来，我们后续的操作都 将在这个数据源的基础上进行。 继续往下看，由于FruitAdapter是继承自RecyclerView.Adapter的，那么就必须重写 onCreateViewHolder()、onBindViewHolder()和getItemCount()这3个方法。 onCreateViewHolder()方法是用于创建ViewHolder实例的，我们在这个方法中将 fruit_item布局加载进来，然后创建一个ViewHolder实例，并把加载出来的布局传入构造 函数当中，最后将ViewHolder的实例返回。onBindViewHolder()方法用于对 RecyclerView子项的数据进行赋值，会在每个子项被滚动到屏幕内的时候执行，这里我们通过 position参数得到当前项的Fruit实例，然后再将数据设置到ViewHolder的ImageView和 TextView当中即可。getItemCount()方法就非常简单了，它用于告诉RecyclerView一共有 多少子项，直接返回数据源的长度就可以了

适配器准备好了之后，我们就可以开始使用RecyclerView了，修改MainActivity中的代码，如 下所示：

```kotlin
class MainActivity:AppCompatActivity(){
    private val fruitList = ArrayList<Fruit>()
    
    override fun onCreate(savedInstanceState:Bundle?){
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        initFruits()
        val layoutManager = LinerLayoutManager(this)
        recycylerView.layoutManager = layoutManager
        val adapter = FruitAdapter(fruitList)
        recyclerView.adapter = adapter
    }
    private fun initFruits() { 
        repeat(2) { 
            fruitList.add(Fruit("Apple", R.drawable.apple_pic)) 
            fruitList.add(Fruit("Banana", R.drawable.banana_pic)) 
            fruitList.add(Fruit("Orange", R.drawable.orange_pic)) 
            fruitList.add(Fruit("Watermelon", R.drawable.watermelon_pic)) 
            fruitList.add(Fruit("Pear", R.drawable.pear_pic)) 
            fruitList.add(Fruit("Grape", R.drawable.grape_pic)) 
            fruitList.add(Fruit("Pineapple", R.drawable.pineapple_pic)) 
            fruitList.add(Fruit("Strawberry", R.drawable.strawberry_pic)) 
            fruitList.add(Fruit("Cherry", R.drawable.cherry_pic)) 
            fruitList.add(Fruit("Mango", R.drawable.mango_pic)) 
        } 
    } 
    
    
}
```

可以看到，这里使用了一个同样的initFruits()方法，用于初始化所有的水果数据。接着在 onCreate()方法中先创建了一个LinearLayoutManager对象，并将它设置到 RecyclerView当中。LayoutManager用于指定RecyclerView的布局方式，这里使用的 LinearLayoutManager是线性布局的意思，可以实现和ListView类似的效果。接下来我们创 建了FruitAdapter的实例，并将水果数据传入FruitAdapter的构造函数中，最后调用 RecyclerView的setAdapter()方法来完成适配器设置，这样RecyclerView和数据之间的关 联就建立完成了。

### 实现横向滚动和瀑布流布局

首先要对fruit_item布局进行修改，因为目前这个布局里面的元素是水平排列的，适用于纵 向滚动的场景，而如果我们要实现横向滚动的话，应该把fruit_item里的元素改成垂直排列 才比较合理。修改fruit_item.xml中的代码，如下所示：

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:orientation="vertical" 
    android:layout_width="80dp" 
    android:layout_height="wrap_content"> 
 
    <ImageView 
        android:id="@+id/fruitImage" 
        android:layout_width="40dp" 
        android:layout_height="40dp" 
        android:layout_gravity="center_horizontal" 
        android:layout_marginTop="10dp" /> 
 
    <TextView 
        android:id="@+id/fruitName" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_gravity="center_horizontal" 
        android:layout_marginTop="10dp" /> 
 
</LinearLayout> 
```

可以看到，我们将LinearLayout改成垂直方向排列，并把宽度设为80 dp。这里将宽度指定为 固定值是因为每种水果的文字长度不一致，如果用wrap_content的话，RecyclerView的子项 就会有长有短，非常不美观，而如果用match_parent的话，就会导致宽度过长，一个子项占 满整个屏幕

然后我们将ImageView和TextView都设置成了在布局中水平居中，并且使用 layout_marginTop属性让文字和图片之间保持一定距离

```kotlin
class MainActivity : AppCompatActivity(){
    private val fruitList = ArrayList<Fruit>()
    
    override fun onCreate(savedInstanceState:Bundle?){
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        initFruits()
        val layoutManager = LinerLayoutMananger(this)
        layoutManager.orientation = LinerLayoutManager.HORIZONTAL
        recyclerView.layoutManager = layoutManager
        val adapter = FruitAdapter(fruitList)
        recyclerView.adapter = adapter
        ...
        
    }
}
```

MainActivity中只加入了一行代码，调用LinearLayoutManager的setOrientation()方法 设置布局的排列方向。默认是纵向排列的，我们传入LinearLayoutManager.HORIZONTAL 表示让布局横行排列，这样RecyclerView就可以横向滚动了。

你可以用手指在水平方向上滑动来查看屏幕外的数据。 为什么ListView很难或者根本无法实现的效果在RecyclerView上这么轻松就实现了呢？这主要 得益于RecyclerView出色的设计。ListView的布局排列是由自身去管理的，而RecyclerView则将这个工作交给了LayoutManager。LayoutManager制定了一套可扩展的布局排列接口， 子类只要按照接口的规范来实现，就能定制出各种不同排列方式的布局了

除了LinearLayoutManager之外，RecyclerView还给我们提供了GridLayoutManager和 StaggeredGridLayoutManager这两种内置的布局排列方式。GridLayoutManager可以用于 实现网格布局，StaggeredGridLayoutManager可以用于实现瀑布流布局。这里我们来实现 一下效果更加炫酷的瀑布流布局，网格布局就作为课后习题，交给你自己来研究了。

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:orientation="vertical" 
    android:layout_width="match_parent" 
    android:layout_height="wrap_content" 
    android:layout_margin="5dp"> 
    <ImageView 
        android:id="@+id/fruitImage" 
        android:layout_width="40dp" 
        android:layout_height="40dp" 
        android:layout_gravity="center_horizontal" 
        android:layout_marginTop="10dp" /> 
    <TextView 
        android:id="@+id/fruitName" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_gravity="left" 
        android:layout_marginTop="10dp" /> 
</LinearLayout> 
```

这里做了几处小的调整，首先将LinearLayout的宽度由80 dp改成了match_parent，因为瀑 布流布局的宽度应该是根据布局的列数来自动适配的，而不是一个固定值。其次我们使用了 layout_margin属性来让子项之间互留一点间距，这样就不至于所有子项都紧贴在一些。最后 还将TextView的对齐属性改成了居左对齐，因为待会我们会将文字的长度变长，如果还是居中 显示就会感觉怪怪的。

接着修改MainActivity中的代码，如下所示：

```kotlin
class MainActivity : AppCompatActivity(){
    private val fruitList = ArrayList<Fruit>()
    
    override fun onCreate(savedInstanceState:Bundle?){
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        initFruits()
        val layoutMaanager = StaggeredGridLayoutManager(3,StaggeredGridLayoutManagre.VERTICAL)
        recyclerView.layoutManager = layoutManager
        val adapter  FruitAdatpe(fruitList)
        recyclerView.adapter = adapter
    }
    
    private fun initFruits(){
                repeat(2) { 
            fruitList.add(Fruit(getRandomLengthString("Apple"), 
                R.drawable.apple_pic)) 
            fruitList.add(Fruit(getRandomLengthString("Banana"), 
                R.drawable.banana_pic)) 
            fruitList.add(Fruit(getRandomLengthString("Orange"), 
                R.drawable.orange_pic)) 
            fruitList.add(Fruit(getRandomLengthString("Watermelon"), 
                R.drawable.watermelon_pic)) 
            fruitList.add(Fruit(getRandomLengthString("Pear"), 
                R.drawable.pear_pic)) 
            fruitList.add(Fruit(getRandomLengthString("Grape"), 
                R.drawable.grape_pic)) 
            fruitList.add(Fruit(getRandomLengthString("Pineapple"), 
                R.drawable.pineapple_pic)) 
            fruitList.add(Fruit(getRandomLengthString("Strawberry"), 
                R.drawable.strawberry_pic)) 
            fruitList.add(Fruit(getRandomLengthString("Cherry"), 
                R.drawable.cherry_pic)) 
            fruitList.add(Fruit(getRandomLengthString("Mango"), 
                R.drawable.mango_pic)) 
        } 
    }
    private fun getRandomLengthString(str:String):String{
        val n = (1...20).random()
        val builder = StringBuilder()
        repeat(n){
            builder.append(str)
        }
        return builder.toString
    }
}
```

首先，在onCreate()方法中，我们创建了一个StaggeredGridLayoutManager的实例。 StaggeredGridLayoutManager的构造函数接收两个参数：第一个参数用于指定布局的列 数，传入3表示会把布局分为3列；第二个参数用于指定布局的排列方向，传入 StaggeredGridLayoutManager.VERTICAL表示会让布局纵向排列。最后把创建好的实例 设置到RecyclerView当中就可以了，就是这么简单

没错，仅仅修改了一行代码，我们就已经成功实现瀑布流布局的效果了。不过由于瀑布流布局 需要各个子项的高度不一致才能看出明显的效果，为此我又使用了一个小技巧。这里我们把眼 光聚焦到getRandomLengthString()这个方法上，这个方法中调用了Range对象的 random()函数来创造一个1到20之间的随机数，然后将参数中传入的字符串随机重复几遍。在 initFruits()方法中，每个水果的名字都改成调用getRandomLengthString()这个方法 来生成，这样就能保证各水果名字的长短差距比较大，子项的高度也就各不相同了。

### RecycleView的点击事件

和ListView一样，RecyclerView也必须能响应点击事件才可以，不然的话就没什么实际用途 了。不过不同于ListView的是，RecyclerView并没有提供类似于 setOnItemClickListener()这样的注册监听器方法，而是需要我们自己给子项具体的View 去注册点击事件。这相比于ListView来说，实现起来要复杂一些

那么你可能就有疑问了，为什么RecyclerView在各方面的设计都要优于ListView，偏偏在点击 事件上却没有处理得非常好呢？其实不是这样的，ListView在点击事件上的处理并不人性化， setOnItemClickListener()方法注册的是子项的点击事件，但如果我想点击的是子项里具 体的某一个按钮呢？虽然ListView也能做到，但是实现起来就相对比较麻烦了。为此， RecyclerView干脆直接摒弃了子项点击事件的监听器，让所有的点击事件都由具体的View去 注册，就再没有这个困扰了。

下面我们来具体学习一下如何在RecyclerView中注册点击事件，修改FruitAdapter中的代 码，如下所示：

```kotlin
class FruitAdapter(val fruitList:List<Fruit>):
	RecyclerView.Adapter<FruitAdapter.ViewHolder>(){
        override fun onCreateViewHolder(parent:ViewGroup,viewType:Int):ViewHolder{
            val view = LayoutInflater.from(parent.context).inflate(R.layout.fruit_item,false)
            val viewHolder = ViewHolder(view)
            viewHolder.itemView.setOnClickListener{
                val position = viewHolder.adapterPosition
                val fruit = fruitList[positon]
                Toast.makeText(parent.context,"you clicked view ${fruit.name}",Toast.LENGTH_SHORT).show()
            }
            viewHolder.fruitImage.setOnClickListener{
                val positon = viewHolder.adapterPositon
                val fruit = fruitList[position]
                Toast.makeText(parent.context,"you clicked image ${fruit.name}"),Toast.LENGTH_SHORT).show()
            }
            return viewHolder
        }
     
    }
```

## ViewBinding的使用

### 项目集成

需要使用ViewBinding的功能，需要在对应的module的build.gradle文件中启用ViewBinding支持。

```
android {
        ...
        viewBinding {
            enabled = true
        }
    }
```

如果您希望在生成绑定类时忽略某个布局文件，请将`tools:viewBindingIgnore="true"`属性添加到相应布局文件的根视图中：

```XML
<LinearLayout
            ...
            tools:viewBindingIgnore="true" >
        ...
    </LinearLayout>
```

### 在Activity中使用

如需设置绑定类的实例以供 Activity 使用，请在 Activity 的onCreate()方法中执行以下步骤：

1. 调用生成的绑定类中包含的静态inflate()方法。此操作会创建该绑定类的实例以供 Activity 使用。
2. 通过调用 getRoot()方法或使用kotlin语法获取对根视图的引用。
3. 将根视图传递到setContentView，使其成为屏幕上的活动视图

```kotlin
private ActivityMainBinding binding;
 
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        binding = ActivityMainBinding .inflate(getLayoutInflater());
        View view = binding.getRoot();
        setContentView(view);
    }
```

配置后使用方式如下：

```kotlin
binding.btnTest.setText("test");
binding.button.setOnClickListener(new View.OnClickListener() {
    // todo
});
```

### 在Adapter中使用ViewBinding

```kotlin
public class MainAdapter extends RecyclerView.Adapter<MainAdapter.ViewHolder> {
 
    private List<String> mList;
 
    public MainAdapter(List<String> list) {
        mList = list;
    }
 
    @NonNull
    @Override
    public MainAdapter.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        //之前的写法
        //View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.layout_comment, parent, false);
        //ViewHolder holder = new ViewHolder(view);
 
        //使用ViewBinding的写法
        LayoutCommentBinding commentBinding = LayoutCommentBinding.inflate(LayoutInflater.from(parent.getContext()), parent, false);
        ViewHolder holder = new ViewHolder(commentBinding);
        return holder;
    }
 
    @Override
    public void onBindViewHolder(@NonNull MainAdapter.ViewHolder holder, int position) {
        holder.mTextView.setText(mList.get(position));
    }
 
    @Override
    public int getItemCount() {
        return mList.size();
    }
 
    static class ViewHolder extends RecyclerView.ViewHolder {
 
        TextView mTextView;
 
        //之前的写法
        //public ViewHolder(@NonNull View itemView) {
        //    super(itemView);
        //    mTextView = itemView.findViewById(R.id.tv_include);
        //}
 
        //使用ViewBinding的写法
        ViewHolder(@NonNull LayoutCommentBinding commentBinding) {
            super(commentBinding.getRoot());
            mTextView = commentBinding.tvInclude;
        }
 
    }
}
```

## ViewPage2

### MainActivyty.java

```java
public class MainActivity extends AppCompatActivity{
    @Override 
    protected void onCreate(BUndle savedInstanceState){
        super.onCreate(savedInstanceState)
            setContentVeiw(R.layout.activity_main);
        ViewPager2 viewPager = findViewById(R.id.viewPager);
        viewPagerAdapter viewPagerAdpater = new ViewPagerAdapter();
        viewPager.setAdapter(viewPagerAdapter);
    }
}
```

### ViewPagerAdapter.java

```java
public class ViewPagerAdapter extends RecyclerView.Adapter<ViewPagerAdapter.ViewPagerViewHolder>{
    private List<String> titles = new ArrayList<>(); 
    private List<Integer> colors = new ArrayLIst<>();
    
    public ViewPagerAdapter(){
        titles.add("hello");
        titles.add("hello");
        titles.add("hello");
        titles.add("hello");
        titles.add("hello");
        titles.add("hello");
        titles.add("hello");
        titles.add("hello");
        titles.add("hello");
        titles.add("hello");
        
        colors.add(R.color.white);
        colors.add(R.color.white);
        colors.add(R.color.white);
        colors.add(R.color.white);
        colors.add(R.color.white);
        colors.add(R.color.white);
        colors.add(R.color.white);
        colors.add(R.color.white);
        colors.add(R.color.white);
        colors.add(R.color.white);
        
    }
    @NonNull
    @Override
    public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent,int viewType){
        return new ViewPagerViewHolder(LayoutInlater.from(parent.getContext()).inflate(R.ayout.item_pager,parent,false));
    }
    
    @Override
    public void onBindViewHolder(@NonNull ViewPagerViewHolder holder,int position){
        holder.mYv.setText(titles.get(position));
        holder.mContainer.setBakcgroundResource(colors.get(position));
    }
    
    @Override
    public int getItemCount(){
        return 10;
    }
    
    class ViewPagerViewHolder extends RecyclerView.ViewHolder{
            TextVeiw mTv;
            RelativeLayout mContainer;
        public viewPagerViewHolder(@NonNull View itemView){
            super(itemView);
            mContainer = itemView.findViewById(R.id.container);
            mTv = itemView.findViewById(R.id.tvTitle);
        }
    
}
```

### item_pager.xml

```xml
<RealtiveLayout xmlns:android="https//schemas.android.com/apk/res"
              android:layout_width = "match_parent"
              android:layout_height = "wrap_content"
              android:id = "@+id/container"
              >
    <TextView
              android:layout_width = "wrap_content"
              android:layout_height = "wrap_content"
              android:id = "+id/tvTitle"
              android:layout_centerInParent = "true"
              android:textColor = "#ff4532"
              android:textSize = "32dp"
              android:text = "hello"
              />
</RelativeLayout>
```

### colors.xml

```xml
<resources>
    <color name="red">#ff4411</color>
    <color name="black">000000</color>
    <color name="white">#ffffff</color>
</resources>
```

## 编写界面的最佳实践

### 制作9-Patch图片

那么9-Patch图片到底有什么实际作用呢？我们还是通过一个例子来看一下吧。首先在 UIBestPractice项目中放置一张气泡样式的图片message_left.png

我们将这张图片设置为LinearLayout的背景图片，修改activity_main.xml中的代码，如下所 示：

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
 android:layout_width="match_parent" 
 android:layout_height="50dp" 
 android:background="@drawable/message_left"> 
</LinearLayout>
```

可以看到，由于message_left的宽度不足以填满整个屏幕的宽度，整张图片被均匀地拉伸 了！这种效果非常差，用户肯定是不能容忍的，这时就可以使用9-Patch图片来进行改善。 制作9-Patch图片其实并不复杂，只要掌握好规则就行了，那么现在我们就来学习一下。 在Android Studio中，我们可以将任何png类型的图片制作成9-Patch图片。首先对着 message_left.png图片右击→Create 9-Patch ﬁle

我们可以在图片的4个边框绘制一个个的小黑点，在上边框和左边框绘制的部分表示当图片需要 拉伸时就拉伸黑点标记的区域，在下边框和右边框绘制的部分表示内容允许被放置的区域。使 用鼠标在图片的边缘拖动就可以进行绘制了，按住Shift键拖动可以进行擦除。绘制完成后效果 如图4.43所示。

最后记得要将原来的message_left.png图片删除，只保留制作好的message_left.9.png图片 即可，因为Android项目中不允许同一文件夹下有两张相同名称的图片（即使后缀名不同也不行）。重新运行程序，效果如图4.44所示。

### 编写精美的聊天界面

开始编写主界面，修改activity_main.xml中的代码，如下所示：

```xml
<LinearLayout xmlns:android:"http:schemas.android.com/apk/res/android"
              android:orientation="vertical"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              background="#d8e0e8">
    <androidx.recyclerview.widget.RecyclerView
                                               android:id="@id/recyclerView"
                                               aandroid:id=layout_width="match_parent"
                                               android:layout_height="0dp"
                                               android:layout_weight="1"/>
    <LinderLayout
                  android:layout_width="match_parent"
                  android:layout_height="wrap_content">
        <EditText
                  android:id="@+id/inputText"
                  android:layout_width="0dp"
                  android:layout_height="wrap_content"
                  android:layout_weight="1"
                  android:hint="Type something here"
                  android:maxLines="2"/>
        <Button
                android:id="@id/send"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Send"/>
    </LinderLayout>
</LinearLayout>
```

 

我们在主界面中放置了一个RecyclerView用于显示聊天的消息内容，又放置了一个EditText用 于输入消息，还放置了一个Button用于发送消息。这里用到的所有属性都是我们之前学过的， 相信你理解起来应该不费力。

然后定义消息的实体类，新建Msg，代码如下所示：

```kotlin
class Msg(val content:String,val type:Int){
    companion object{
       const val TYPE_RECEIVED = 0
       const val TYPE_SENT = 1
    }
}
```

Msg类中只有两个字段：content表示消息的内容，type表示消息的类型。其中消息类型有两 个值可选：TYPE_RECEIVED表示这是一条收到的消息，TYPE_SENT表示这是一条发出的消息。这里我们将TYPE_RECEIVED和TYPE_SENT定义成了常量，定义常量的关键字是const， 注意只有在单例类、companion object或顶层方法中才可以使用const关键字。

接下来开始编写RecyclerView的子项布局，新建msg_left_item.xml，代码如下所示：

```xml
<FrameLayout xmlns:"http://schemas.android.com/apk/res/android"
             android:layout_width="match_parent"
             android:layout_height="wrap_content"
             android:pddding="10dp">
    <LinearLayout
                  android:layout_width="wrap_content"
                  android:layout_height="wrap_content"
                  android:layout_grativity="left"
                  android:background="drawable/message_left">
        <TextView
                  android:id="@id/leftMsg"
                  android:layout_width="wrap_content"
                  android:layout_height="wrap_content"
                  android:layout_gravity="center"
                  android:layout_margin="10dp"
                  android:textColor="#fff"/>
    </LinearLayout>
</FrameLayout>
```

这是接收消息的子项布局。这里我们让收到的消息居左对齐，并使用message_left.9.png作为 背景图。

类似地，我们还需要再编写一个发送消息的子项布局，新建msg_right_item.xml，代码如下所 示

```xml
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
             android:layout_width="match_parent"
             android:layout_height="wrap_content"
             android:padding="10dp">
    <LinerLayout
                 android:layout_width="wrap_content"
                 android:layout_height="wrap_content"
                 android:layout_gravity="right"
                 android:background="@drawable/message_right">
        <TextView
                  android:id="@id/rightMsg"
                  android:layout_width="wrap_content"
                  android:layout_height="wrap_content"
                  android:layout_margin="10dp"
                  android:textColor="#000"/>
    </LinerLayout>
</FrameLayout>
```

这里我们让发出的消息居右对齐，并使用message_right.9.png作为背景图，基本上和刚才的 msg_left_item.xml是差不多的

接下来需要创建RecyclerView的适配器类，新建类MsgAdapter，代码如下所示：

```kotlin
class MsgAdapter(val msgList:List<Msg>):RecyclerView.Adapter<RecyclerView.ViewHolder>(){
    inner class LeftViewHolder(view:View):RecyclerView.ViewHolder(view){
        val leftMsg: TextView = view.findViewById(R.id.leftMsg)
    }
    inner class RightViewHolder(view:View):RecyclerView.ViewHOlder(view){
        val rightMsg: TextView = view.findViewById(R.id.rightMsg)
    }
    override fun getItemViewType(position:Int):Int{
        val msg = msgList[position]
        return msg.Type
    }
    override fun onCreateViewHolder(parent:ViewGroup,viewType:Int) = if(viewType==Msg.TYPE_RECEIVED){
        val view = LayoutInflater.fron(parent.context).inflate(R.layout.msg_left_item,parent,false)
        LeftViewHolder(view)
    }else{
        val view = LayoutInflater.from(parent.context).inflate(R.layout.msg_right_item,parent,false)
        RightViewHolder(view)
    }
    override fun onBindViewHolder(holder:RecyclerVIew.ViewHolder,position:Int){
        val msg = msgList[position]
        when(holder){
            is LeftViewHolder->holder.leftMsg.text = msg.content
            is RightViewHolder->holder.rightMst.text = msg.content
            else -> throw IlleaglArgumentException()
        }
    }
}
```

上述代码中用到了一个新的知识点：根据不同的viewType创建不同的界面。首先我们定义了 LeftViewHolder和RightViewHolder这两个ViewHolder，分别用于缓存 msg_left_item.xml和msg_right_item.xml布局中的控件。然后要重写 getItemViewType()方法，并在这个方法中返回当前position对应的消息类型。

接下来的代码你应该就比较熟悉了，和我们之前学习的RecyclerView用法是比较相似的，只是 要在onCreateViewHolder()方法中根据不同的viewType来加载不同的布局并创建不同的 ViewHolder。然后在onBindViewHolder()方法中判断ViewHolder的类型：如果是 LeftViewHolder，就将内容显示到左边的消息布局；如果是RightViewHolder，就将内容 显示到右边的消息布局。

最后修改MainActivity中的代码，为RecyclerView初始化一些数据，并给发送按钮加入事件响 应，代码如下所示：

```kotlin
class MainActivity : AppCompatActivity(),View.OnClickListener{
    private val msgList = ArrayLIst<Msg>()
    private var adapter:MsgAdapter? = null
    override fun onCreate(savedInstanceState:Bundle?){
        super.onCreate(savedInstanceState)
        setContentVeiw(R.layout.activity_main)
        initMsg()
        val layoutManager = LinearLayoutManager(this)
        recyclerView.layoutManager = layoutManager
        adapter = MsgAdapter(magList)
        recyclerView.adapter = adapter
        send.setOnClickListner(this)
    }
    override fun onClick(v:View?){
        when(v){
            send->{
                val content = inputText.text.toString()
                if(content.isNotEmpty()){
                    val msg = Msg(content,Msg.TYPE_SENT)
                    magList.add(msg)
                    adapter?.notifyItemInserted(msgLsig.size-1)
                    recyclerView.scrollToPosition(msgLisg.size-1)
                    inputText.setText("")
                }
            }
        }
    }
    private fun initMst(){
        val masl = Msg("Hello guy.",Msg.TYPE_RECEIVED)
        msgLisg.add(msg1)
        val msg2 = Msg("Hello. Who is that?",Msg.TYPE_SENT)
        msgList.add(msg2)
        val msg3 = Msg("This is Tom.Nice talking to you",Msg.TYPE_RECEIVED)
        msgList.add(msg3)
    }
}

```

## Kotlin课堂:延迟初始化和密封类

### 对变量延迟初始化

延迟初始化使用的是lateinit关键字，它可以告诉Kotlin编译器，我会在晚些时候对这个变量 进行初始化，这样就不用在一开始的时候将它赋值为null了。

```kotlin
private lateinit var adapter:MsgAdapter
```

当然，使用lateinit关键字也不是没有任何风险，如果我们在adapter变量还没有初始化的 情况下就直接使用它，那么程序就一定会崩溃，并且抛出一个 UninitializedPropertyAccessException异常

另外，我们还可以通过代码来判断一个全局变量是否已经完成了初始化，这样在某些时候能够 有效地避免重复对某一个变量进行初始化操作，示例代码如下

```kotlin
if(::adapter.isInitialized){
    adapter = MsgAdpater(msgList)
}
```

具体语法就是这样，::adapter.isInitialized可用于判断adapter变量是否已经初始 化。虽然语法看上去有点奇怪，但这是固定的写法。然后我们再对结果进行取反，如果还没有 初始化，那么就立即对adapter变量进行初始化，否则什么都不用做。

### 使用密封类优化代码

首先来了解一下密封类具体的作用，这里我们来看一个简单的例子。新建一个Kotlin文件，文件 名就叫Result.kt好了，然后在这个文件中编写如下代码：

```kotlin
interface Result
class Success(val msg:String):Result
class Failure(val error:Exception):Result
```

这里定义了一个Result接口，用于表示某个操作的执行结果，接口中不用编写任何内容。然后 定义了两个类去实现Result接口：一个Success类用于表示成功时的结果，一个Failure类 用于表示失败时的结果，这样就把准备工作做好了。

接下来再定义一个getResultMsg()方法，用于获取最终执行结果的信息，代码如下所示

```kotlin
fun getResultMsg(result:Result) = when(result){
    is Success -> result.msg
    is Failure -> result.error.message
    else -> throw IllegalArgumentException()
}
```

etResultMsg()方法中接收一个Result参数。我们通过when语句来判断：如果Result属 于Success，那么就返回成功的消息；如果Result属于Failure，那么就返回错误信息。到 目前为止，代码都是没有问题的，但比较让人讨厌的是，接下来我们不得不再编写一个else条 件，否则Kotlin编译器会认为这里缺少条件分支，代码将无法编译通过。但实际上Result的执 行结果只可能是Success或者Failure，这个else条件是永远走不到的，所以我们在这里直接 抛出了一个异常，只是为了满足Kotlin编译器的语法检查而已。

另外，编写else条件还有一个潜在的风险。如果我们现在新增了一个Unknown类并实现 Result接口，用于表示未知的执行结果，但是忘记在getResultMsg()方法中添加相应的条 件分支，编译器在这种情况下是不会提醒我们的，而是会在运行的时候进入else条件里面，从 而抛出异常并导致程序崩溃。

密封类的关键字是sealed class，它的用法同样非常简单，我们可以轻松地将Result接口改 造成密封类的写法：

```kotlin
sealed class Result 
class Success(val msg:String):Result()
class Failure(val reror:Exception):Result()
```

可以看到，代码并没有什么太大的变化，只是将interface关键字改成了sealed class。另 外，由于密封类是一个可继承的类，因此在继承它的时候需要在后面加上一对括号，这一点我 们在第2章就学习过了。

那么改成密封类之后有什么好处呢？你会发现现在getResultMsg()方法中的else条件已经不 再需要了，如下所示：

```kotlin
fun getResultMsg(result: Result) = when (result) { 
 is Success -> result.msg 
 is Failure -> "Error is ${result.error.message}" 
} 
```

为什么这里去掉了else条件仍然能编译通过呢？这是因为当在when语句中传入一个密封类变量 作为条件时，Kotlin编译器会自动检查该密封类有哪些子类，并强制要求你将每一个子类所对应 的条件全部处理。这样就可以保证，即使没有编写else条件，也不可能会出现漏写条件分支的 情况。而如果我们现在新增一个Unknown类，并也让它继承自Result，此时 getResultMsg()方法就一定会报错，必须增加一个Unknown的条件分支才能让代码编译通 过。

了解了这么多关于密封类的知识，接下来我们看一下它该如何结合MsgAdapter中的 ViewHolder一起使用，并顺便优化一下MsgAdapter中的代码。

观看MsgAdapter现在的代码，你会发现onBindViewHolder()方法中就存在一个没有实际作 用的else条件，只是抛出了一个异常而已。对于这部分代码，我们就可以借助密封类的特性来 进行优化。首先删除MsgAdapter中的LeftViewHolder和RightViewHolder，然后新建一个 MsgViewHolder.kt文件，在其中加入如下代码：

```kotlin
sealed class MsgViewHolder(view: View) : RecyclerView.ViewHolder(view) 
 
class LeftViewHolder(view: View) : MsgViewHolder(view) { 
 val leftMsg: TextView = view.findViewById(R.id.leftMsg) 
} 
 
class RightViewHolder(view: View) : MsgViewHolder(view) { 
 val rightMsg: TextView = view.findViewById(R.id.rightMsg) 
} 
```

# 变量

## val

val（value的简写）用来声明一个不可变的变量，这种变量在初始赋值之后就再也不能重新赋 值，对应Java中的final变量。

## var

var（variable的简写）用来声明一个可变的变量，这种变量在初始赋值之后仍然可以再被重新 赋值，对应Java中的非final变量。

```kotlin
fun main(){
    val a=10
    println("a = " + a)
}
```

## 显示的进行变量声明

```kotlin
val a: Int = 10
```

# 函数

## 语法规则

```kotlin
fun methodName(param1: Int, param2: Int): Int{
	return 0
}
```

- 函数名后面紧跟着一对括号，里面可以声明该函数接收什么参数，参数的数量可以是任意多
  个，例如上述示例就表示该函数接收两个Int类型的参数。参数的声明格式是“参数名: 参数类
  型”，其中参数名也是可以随便定义的，这一点和函数名类似。如果不想接收任何参数，那么写
  一对空括号就可以了
- 参数括号后面的那部分是可选的，用于声明该函数会返回什么类型的数据，上述示例就表示该
  函数会返回一个Int类型的数据。如果你的函数不需要返回任何数据，这部分可以直接不写。

## 例子

```kotlin
package com.example.helloworld
import kotlin.math.max
fun main(){
    val num1:Int = 10
    val num2:Int = 100
    val value = largerNumber(num1,num2)
    println("larger number is " + value)
}
fun largerNumber(num1:Int,num2:Int):Int{
    return max(num1,num2)
}
```

### 语法糖

当一个函数中只有一行代码时，Kotlin允许我们不必编写函数体，可以直接将唯一的一行代码写 在函数定义的尾部，中间用等号连接即可。

```kotlin
fun largerNumber(num1:Int,num2:Int):Int =max(num1,num2)
```

使用这种语法，return关键字也可以省略了，等号足以表达返回值的意思。另外，还记得 Kotlin出色的类型推导机制吗？在这里它也可以发挥重要的作用。由于max()函数返回的是一个 Int值，而我们在largerNumber()函数的尾部又使用等号连接了max()函数，因此Kotlin可 以推导出largerNumber()函数返回的必然也是一个Int值，这样就不用再显式地声明返回值 类型了，代码可以进一步简化成如下形式：

```kotlin
fun largerNumber(num1:Int,num2:Int)=max(num1,num2)
```

# 程序的逻辑控制

## if条件语句

```kotlin
fun largerNumber(num1:Int,num2:Int):Int{
    var value = 0
    if(num1>num2){
        value=num1
    }else{
        value=num2
    }
    return value
}
```

Kotlin中的if语句相比于Java有一个额外的功能，它是可以有返回值的，返回值就是if语句每 一个条件中最后一行代码的返回值。因此，上述代码就可以简化成如下形式

```kotlin
fun largerNumber(num1:Int,num2:Int):Int{
    var value = if(num1>num2){
        num1
    }else{
        num2
    }
    return value
}
```

仔细观察上述代码，你会发现value其实也是一个多余的变量，我们可以直接将if语句返回， 这样代码将会变得更加精简，如下所示

```kotlin
fun largerNumber(num1:Int,num2:Int){
    return if(num1>num2){
        num1
    }else{
        num2;
    }
}
```

使用语法糖，使得代码更加精简

```kotlin
fun largerNumber(num1:Int,num2:Int) = if(num1>num2){
    num1
}else{
    num2
}
```

## when条件语句

编写一个查询考试成绩的功能，输入一个学生的姓名，返回该学生考试的分数。我 们先用上一小节学习的if语句来实现这个功能

```kotlin
fun getScore(name:String) = if(name=="Tom"){
    86
}else if(name=="Jim"){
    77
}else if(name=="Jack"){
    95
}else if(name=="Lily"){
    100
}else{
    0
}
```

虽然上述代码确实可以实现我们想要的功能，但是写了这么多的if和else，你有没有觉得代码 很冗余？没错，当你的判断条件非常多的时候，就是应该考虑使用when语句的时候，现在我们 将代码改成如下写法

```kotlin
fun getScore(name:String) = when(name){
    "Tom"->86
    "Jim"->77
    "Jack"->95
    "Lily"->100
    else->0
}
```

when语句允许传入一个任意类型的参数，然后可以在when的结构体中定义一系列的条件，格式 是

```
匹配值 -> {执行逻辑}
```

当你的执行逻辑只有一行代码时，{ }可以省略。这样再来看上述代码就很好理解了吧

除了精确匹配之外，when语句还允许进行类型匹配。什么是类型匹配呢？这里我再举个例子

定义一个checkNumber()函数，如下所示

```kotlin
fun checkNumber(num:Number){
    when(num){
        is Int->println("number is Int")
        is Double->println("number is Double")
        else ->println("number not support")
    }
}
```

上述代码中，is关键字就是类型匹配的核心，它相当于Java中的instanceof关键字。由于 checkNumber()函数接收一个Number类型的参数，这是Kotlin内置的一个抽象类，像Int、 Long、Float、Double等与数字相关的类都是它的子类，所以这里就可以使用类型匹配来判断传入的参数到底属于什么类型，如果是Int型或Double型，就将该类型打印出来，否则就打 印不支持该参数的类型。

when语句的基本用法就是这些，但其实when语句还有一种不带参数的用法，虽然这种用法可能 不太常用，但有的时候却能发挥很强的扩展性

拿刚才的getScore()函数举例，如果我们不在when语句中传入参数的话，还可以这么写

```kotlin
fun getScore(name:String) = when{
    name=="Tom"->86
    name=="Jim"->77
    name=="Jack"->95
    name=="Lily"->100
    else->0
}
```

可以看到，这种用法是将判断的表达式完整地写在when的结构体当中。注意，Kotlin中判断字 符串或对象是否相等可以直接使用==关键字，而不用像Java那样调用equals()方法。可能你 会觉得这种无参数的when语句写起来比较冗余，但有些场景必须使用这种写法才能实现。举个 例子，假设所有名字以Tom开头的人，他的分数都是86分，这种场景如果用带参数的when语句 来写就无法实现，而使用不带参数的when语句就可以这样写：

```kotlin
fun getScore(name:String) = when{
    name.startWith("Tom")->86
    name=="Jim"->77
    name=="Jack"->95
    name=="Lily"->100
    else->0
}
```

## 循环语句

在开始学习for-in循环之前，还得先向你普及一个区间的概念，因为这也是Java中没有的东 西。我们可以使用如下Kotlin代码来表示一个区间

```kotlin
val range=0..10
```

在开始学习for-in循环之前，还得先向你普及一个区间的概念，因为这也是Java中没有的东 西。我们可以使用如下Kotlin代码来表示一个区间

有了区间之后，我们就可以通过for-in循环来遍历这个区间，比如在main()函数中编写如下 代码：

```kotlin
fun main(){
    for(i in 0..10){
        println(i)
    }
}
```

Kotlin中可以使用until关键字来创建一个左闭右开的区间，如 下所示：

```kotlin
val range=0 until 10
```

默认情况下，for-in循环每次执行循环时会在区间范围内递增1，相当于Java for-i循环中 i++的效果，而如果你想跳过其中的一些元素，可以使用step关键字：

```kotlin
fun main(){
    for(i in 0 until 10 step 2){
        println(i)
    }
}
```

上述代码表示在遍历[0, 10)这个区间的时候，每次执行循环都会在区间范围内递增2，相当于 for-i循环中i = i + 2的效果。

不过，前面我们所学习的..和until关键字都要求区间的左端必须小于等于区间的右端，也就 是这两种关键字创建的都是一个升序的区间。如果你想创建一个降序的区间，可以使用downTo 关键字，用法如下：

```kotlin
fun main(){
    for(i in 10 downTo 1){
        println(i)
    }
}
```

# 面向对象

## 类与对象

```kotlin
package com.example.helloworld

class Person {
    var name = ""
    var age = 0
    fun eat(){
        println(name+" is eating. He is "+ age +"years old.")
    }
}
fun main(){
    val p=Person()
    p.name="Jack"
    p.age=19
    p.eat()
}
```

## 继承与构造函数

Student类

```kotlin
package com.example.helloworld

class Student {
    var sno=""
    var grade = 0
}
```

第一件事，使Person类可以被继承。可能很多人会觉得奇怪，尤其是有Java编程经验的人。一 个类本身不就是可以被继承的吗？为什么还要使Person类可以被继承呢？这就是Kotlin不同的 地方，在Kotlin中任何一个非抽象类默认都是不可以被继承的，相当于Java中给类声明了final 关键字。之所以这么设计，其实和val关键字的原因是差不多的，因为类和变量一样，最好都是 不可变的，而一个类允许被继承的话，它无法预知子类会如何实现，因此可能就会存在一些未 知的风险。Effective Java这本书中明确提到，如果一个类不是专门为继承而设计的，那么就应 该主动将它加上final声明，禁止它可以被继承

很明显，Kotlin在设计的时候遵循了这条编程规范，默认所有非抽象类都是不可以被继承的。之 所以这里一直在说非抽象类，是因为抽象类本身是无法创建实例的，一定要由子类去继承它才 能创建实例，因此抽象类必须可以被继承才行，要不然就没有意义了。由于Kotlin中的抽象类和 Java中并无区别，这里我就不再多讲了。 既然现在Person类是无法被继承的，我们得让它可以被继承才行，方法也很简单，在Person 类的前面加上open关键字就可以了，如下所示

```kotlin
open class Person{

}
```

加上open关键字之后，我们就是在主动告诉Kotlin编译器，Person这个类是专门为继承而设计 的，这样Person类就允许被继承了

第二件事，要让Student类继承Person类。在Java中继承的关键字是extends，而在Kotlin 中变成了一个冒号，写法如下

```kotlin
class Student : Person(){
    var sno = ""
    var grade = 0
}
```

任何一个面向对象的编程语言都会有构造函数的概念，Kotlin中也有，但是Kotlin将构造函数分 成了两种：主构造函数和次构造函数

主构造函数将会是你最常用的构造函数，每个类默认都会有一个不带参数的主构造函数，当然 你也可以显式地给它指明参数。主构造函数的特点是没有函数体，直接定义在类名的后面即 可。比如下面这种写法：

```kotlin
calss Student(val sno:String,val grade:Int):Person(){
    
}
```

主构造函数将会是你最常用的构造函数，每个类默认都会有一个不带参数的主构造函数，当然 你也可以显式地给它指明参数。主构造函数的特点是没有函数体，直接定义在类名的后面即 可。比如下面这种写法：

```kotlin
val student = Student("a123",5)
```

你可能会问，主构造函数没有函数体，如果我想在主构造函数中编写一些逻辑，该怎么办呢？ Kotlin给我们提供了一个init结构体，所有主构造函数中的逻辑都可以写在里面：

```kotlin
class Student(val sno:String,val grade:Int):Person(){
	init{
        println("sno is "+sno)
        println("grade is "+grade)
    }
}
```

果我们将Person改造一下，将姓名和年龄都放到主构造函数当中，如下所示

```kotlin
open class Person(val name:String,val age:Int){
    
}
```

我们可以在Student类的主构造函 数中加上name和age这两个参数，再将这两个参数传给Person类的构造函数，代码如下所示

```kotlin
class Student(val sno:String,val grade:Int,name:String,age:Int):Person(name,age){
    
}
```

注意，我们在Student类的主构造函数中增加name和age这两个字段时，不能再将它们声明成 val，因为在主构造函数中声明成val或者var的参数将自动成为该类的字段，这就会导致和父 类中同名的name和age字段造成冲突。因此，这里的name和age参数前面我们不用加任何关键 字，让它的作用域仅限定在主构造函数当中即可。

现在就可以通过如下代码来创建一个Student类的实例：

```kotlin
val student = Student("a123",5,"Jack",19)
```

任何一个类只能有一个主构造函数，但是可以有多个次构造函数。次构造函数也可 以用于实例化一个类，这一点和主构造函数没有什么不同，只不过它是有函数体的。

```kotlin
class Student(val sno:String,val grade:Int,name:String,age:Int):Person(name,age){
    constructor(name:String,age:Int):this(" ",0,name,age){
        
    }
    constructor():this("",0){
        
    }
}
```

次构造函数是通过constructor关键字来定义的，这里我们定义了两个次构造函数：第一个次 构造函数接收name和age参数，然后它又通过this关键字调用了主构造函数，并将sno和 grade这两个参数赋值成初始值；第二个次构造函数不接收任何参数，它通过this关键字调用 了我们刚才定义的第一个次构造函数，并将name和age参数也赋值成初始值，由于第二个次构 造函数间接调用了主构造函数，因此这仍然是合法的。

那么现在我们就拥有了3种方式来对Student类进行实体化，分别是通过不带参数的构造函数、 通过带两个参数的构造函数和通过带4个参数的构造函数，对应代码如下所示

```kotlin
val student1 = Student()
val student2 = Student("Jack",19)
val student3 = Student("a123",5,"Jack",19)
```

那么接下来我们就再来看一种非常特殊的情况：类中只有次构造函数，没有主构造函数。这种 情况真的十分少见，但在Kotlin中是允许的。当一个类没有显式地定义主构造函数且定义了次构 造函数时，它就是没有主构造函数的。我们结合代码来看一下

```kotlin
class Student:Person{
    constructor(name:String,age:Int):super(name,age){
        
    }
}
```

注意这里的代码变化，首先Student类的后面没有显式地定义主构造函数，同时又因为定义了 次构造函数，所以现在Student类是没有主构造函数的。那么既然没有主构造函数，继承 Person类的时候也就不需要再加上括号了。其实原因就是这么简单，只是很多人在刚开始学习 Kotlin的时候没能理解这对括号的意义和规则，因此总感觉继承的写法有时候要加上括号，有时 候又不要加，搞得晕头转向的，而在你真正理解了规则之后，就会发现其实还是很好懂的

## 接口

接口是用于实现多态编程的重要组成部分。我们都知道，Java是单继承结构的语言，任何一个 类最多只能继承一个父类，但是却可以实现任意多个接口，Kotlin也是如此

### Study接口

```kotlin
interface Study{
    fun readBooks()
    fun doHomework()
}
```

接下来就可以让Student类去实现Study接口了，这里我将Student类原有的代码调整了一 下，以突出继承父类和实现接口的区别

```kotlin
class Student(name:String,age:Int):Person(name,age),Study{
    override fun readBooks(){
        println(name+" is reading.")
    }
    override fun doHomework(){
        println(name+" is doing homework.")
    }
}
```

现在我们可以在main()函数中编写如下代码来调用这两个接口中的函数

```kotlin
fun main(){
    val student=Studnet("Jack",19)
    doStudy(student)
}
fun doStudy(study:Study){
    study.redBooks()
    study.doHomework()
}
```

### Java和Kotlin函数可见性修饰符对照表

![](C:\Hexo-Blog\blog-demo\source\image\kotlin1.png)

# Lambda编程

## 集合的创建和遍历

现在我们提出一个需求，创建一个包含许多水果名称的集合。如果是在Java中你会怎么实现？ 可能你首先会创建一个ArrayList的实例，然后将水果的名称一个个添加到集合中。当然，在 Kotlin中也可以这么做

```kotlin
val list = ArrayList<String>()
list.add("Apple")
list.add("Banana")
list.add("Orange")
list.add("Pear")
list.add("Grape")
```

但是这种初始化集合的方式比较烦琐，为此Kotlin专门提供了一个内置的listOf()函数来简化 初始化集合的写法，如下所示

```kotlin
val list = listOf("Apple","Banana","Orange","Pear","Grape")
```

可以看到，这里仅用一行代码就完成了集合的初始化操作

还记得我们在学习循环语句时提到过的吗？for-in循环不仅可以用来遍历区间，还可以用来遍 历集合。现在我们就尝试一下使用for-in循环来遍历这个水果集合，在main()函数中编写如 下代码：

```kotlin
fun main(){
    val list = listOf("Apple","Banana","Orange","Pear","Grape")
    for(fruit in list){
        println("fruit")
    }
}
```

不过需要注意的是，listOf()函数创建的是一个不可变的集合。你也许不太能理解什么叫作不 可变的集合，因为在Java中这个概念不太常见。不可变的集合指的就是该集合只能用于读取， 我们无法对集合进行添加、修改或删除操作

至于这么设计的理由，和val关键字、类默认不可继承的设计初衷是类似的，可见Kotlin在不可 变性方面控制得极其严格。那如果我们确实需要创建一个可变的集合呢？也很简单，使用 mutableListOf()函数就可以了，示例如下

```kotlin
fun main(){
    val list = mutableListOf("Apple","Banana","Orange","Pear","Grape")
    list.add("Watermelon")
    for(fruit in list){
        println(fruit)
    }
}
```

前面我们介绍的都是List集合的用法，实际上Set集合的用法几乎与此一模一样，只是将创建 集合的方式换成了setOf()和mutableSetOf()函数而已。大致代码如下

```kotlin
fun main(){
    val set = setOf("Apple","Banana","Orange","Pear","Grape")
    for(fruit in set){
        println(fruit)
    }
}
```

最后再来看一下Map集合的用法。Map是一种键值对形式的数据结构，因此在用法上和List、 Set集合有较大的不同。传统的Map用法是先创建一个HashMap的实例，然后将一个个键值对数 据添加到Map中。比如这里我们给每种水果设置一个对应的编号，就可以这样写

```kotlin
val map = HashMap<String,Int>()
map.put("Apple",1)
map.put("Banana",2)
map.put("Orange",3)
map.put("Pear",4)
map.put("Grape",5)
```

我之所以先用这种写法，是因为这种写法和Java语法是最相似的，因此可能最好理解。但其实 在Kotlin中并不建议使用put()和get()方法来对Map进行添加和读取数据操作，而是更加推荐 使用一种类似于数组下标的语法结构，比如向Map中添加一条数据就可以这么写

```kotlin
map["Apple"]=1
```

而从Map中读取一条数据就可以这么写：

```kotlin
val number = map["Apple"]
```

因此，上述代码经过优化过后就可以变成如下形式

```kotlin
val map = HashMap<String,Int>()
map["Apple"]=1
map["Banana"]=2
map["Orange"]=3
map["Pear"]=4
map["Grape"]=5
```

当然，这仍然不是最简便的写法，因为Kotlin毫无疑问地提供了一对mapOf()和 mutableMapOf()函数来继续简化Map的用法。在mapOf()函数中，我们可以直接传入初始化 的键值对组合来完成对Map集合的创建：

```kotlin
val map = mapOf("Apple" to 1,"Banana" to 2,"Orange" to 3,"Pear" to 4,"Grape" to 5)
```

这里的键值对组合看上去好像是使用to这个关键字来进行关联的，但其实to并不是关键字，而 是一个infix函数，我们会在本书第9章的Kotlin课堂中深入探究infix函数的相关内容。

最后再来看一下如何遍历Map集合中的数据吧，其实使用的仍然是for-in循环。在main()函 数中编写如下代码



```kotlin
fun main(){
    val map = mapOf("Apple" to 1,"Banana" to 2,"Orange" to 3,"Pear" to 4,"Grape" to 5)
    for((fruit,number) in map){
        println("fruit is "+fruit+", number is "+number)
    }
}
```

下Lambda表达式的语法结构

```
{参数名1：参数类型，参数名2：参数类型 ->函数体}
```

这是Lambda表达式最完整的语法结构定义。首先最外层是一对大括号，如果有参数传入到 Lambda表达式中的话，我们还需要声明参数列表，参数列表的结尾使用一个->符号，表示参 数列表的结束以及函数体的开始，函数体中可以编写任意行代码（虽然不建议编写太长的代 码），并且最后一行代码会自动作为Lambda表达式的返回值

理解了maxBy函数的工作原理之后，我们就可以开始套用刚才学习的Lambda表达式的语法结 构，并将它传入到maxBy函数中了，如下所示

```kotlin
val list = listOf("Apple","Banana","Orange","Pear","Grape","Watermelon")
val lambda = {fruit:String->fruit.length}
val maxLengthFruit = list.maxBy(lambda)
```

下面我们就开始对这段代 码一步步进行简化。

首先，我们不需要专门定义一个lambda变量，而是可以直接将lambda表达式传入maxBy函数 当中，因此第一步简化如下所示

```kotlin
val maxLengthFruit = list.maxBy({fruit:String->fruit.length})
```

然后Kotlin规定，当Lambda参数是函数的最后一个参数时，可以将Lambda表达式移到函数括 号的外面，如下所示：

```kotlin
val maxLengthFruit = list.maxBy(){fruit:String->fruit.length}
```

接下来，如果Lambda参数是函数的唯一一个参数的话，还可以将函数的括号省略

```kotlin
val maxLengthFruit = list.maxBy{fruit:String->fruit.length}
```

这样代码看起来就变得清爽多了吧？但是我们还可以继续进行简化。由于Kotlin拥有出色的类型 推导机制，Lambda表达式中的参数列表其实在大多数情况下不必声明参数类型，因此代码可 以进一步简化成

```kotlin
val maxLengthFruit = list.maxBy{fruit->fruit.length}
```

最后，当Lambda表达式的参数列表中只有一个参数时，也不必声明参数名，而是可以使用it 关键字来代替，那么代码就变成了

```kotlin
val maxLengthFrut = list.maxBy{it.length}
```

map函数的功能非常强大，它可以按照我们的需求对集合中的元素进行任意的映射转换，上面只 是一个简单的示例而已。除此之外，你还可以将水果名全部转换成小写，或者是只取单词的首 字母，甚至是转换成单词长度这样一个数字集合，只要在Lambda表示式中编写你需要的逻辑 即可。

接下来我们再来学习另外一个比较常用的函数式API——filter函数。顾名思义，filter函数 是用来过滤集合中的数据的，它可以单独使用，也可以配合刚才的map函数一起使用。 比如我们只想保留5个字母以内的水果，就可以借助filter函数来实现，代码如下所示

```kotlin
fun main(){
    val list = listOf("Apple","Banana","Orange","Pear","Grape","Watermelon")
    val newList = list.filter{it.length<=5}
    				.map{it.toUpperCase()}
    for(fruit in newList){
        println(fruit)
    }
}
```

接下来我们继续学习两个比较常用的函数式API——any和all函数。其中any函数用于判断集 合中是否至少存在一个元素满足指定条件，all函数用于判断集合中是否所有元素都满足指定条 件。由于这两个函数都很好理解，我们就直接通过代码示例学习了

```kotlin
fun main(){
    val list = listOf("Apple","Banana","Orange","Pear","Grape","Watermelon")
    val anyResult = list.any{it.length<=5}
    val allResult = lsit.all{it.length<=5}
    println("anyResult is "+anyResult +", allResult is "+allResult)
}
```

## Java函数式API的使用

这里我们就通过Java的线程类Thread来学习一下。

```java
new Thread(new Runnable(){
    @Override
    public void run(){
        System.out.println("Thread is running");
    }
}).start();
```

而如果直接将这段代码翻译成Kotlin版本，写法将如下所示：

```kotlin
Thread(object:Runnale{
    override fun run(){
        println("Thread is running")
    }
}).start()
```

Kotlin中匿名类的写法和Java有一点区别，由于Kotlin完全舍弃了new关键字，因此创建匿名类 实例的时候就不能再使用new了，而是改用了object关键字。这种写法虽然算不上复杂，但是 相比于Java的匿名类写法，并没有什么简化之处

但是别忘了，目前Thread类的构造方法是符合Java函数式API的使用条件的，下面我们就看看 如何对代码进行精简，如下所示：

```kotlin
Thread(Runnable{
    println("Thread is running")
}).start()
```

另外，如果一个Java方法的参数列表中有且仅有一个Java单抽象方法接口参数，我们还可以将 接口名进行省略，这样代码就变得更加精简了：

```kotlin
Thread({println("Thread is running")}).start()
```

# 空指针检查

Kotlin将空指针异常的检查提前到了编译时期，如果我们的程序存在空指针异常的风 险，那么在编译的时候会直接报错，修正之后才能成功运行，这样就可以保证程序在运行时期 不会出现空指针异常了

## 可为空的类型系统

那么可为空的类型系统是什么样的呢？很简单，就是在类名的后面加上一个问号。比如，Int表 示不可为空的整型，而Int?就表示可为空的整型；String表示不可为空的字符串，而 String?就表示可为空的字符串

## 判空辅助工具

首先学习最常用的?.操作符。这个操作符的作用非常好理解，就是当对象不为空时正常调用相 应的方法，当对象为空时则什么都不做。比如以下的判空处理代码：

```kotlin
if(a!=null){
    a.doSomething()
}
```

这段代码使用?.操作符就可以简化成：

```
a?.doSomething()
```

了解了?.操作符的作用，下面我们来看一下如何使用这个操作符对doStudy()函数进行优化， 代码如下所示

```kotlin
fun doStudy(study:Study?){
    study?.readBooks()
    study?.doHomework()
}
```

下面我们再来学习另外一个非常常用的?:操作符。这个操作符的左右两边都接收一个表达式， 如果左边表达式的结果不为空就返回左边表达式的结果，否则就返回右边表达式的结果。观察 如下代码：

```kotlin
val c = if(a!=null){
    a
}else{
    b
}
```

这段代码的逻辑使用?:操作符就可以简化成：

```kotlin
val c = a?:b
```

使用非空断言工具，写法是在对象的后面加 上!!

```kotlin
fun printUpperCase(){
    vla upperCase = content!!.toUpperCase()
    println(upperCase)
}
```

最后我们再来学习一个比较与众不同的辅助工具——let。let既不是操作符，也不是什么关键 字，而是一个函数。这个函数提供了函数式API的编程接口，并将原始调用对象作为参数传递到 Lambda表达式中。示例代码如下

```kotlin
obj.let{obj2>
//编写具体的业务逻辑
}
```

# Kotlin中的小魔术

## 字符串内嵌表达式

首先来看一下Kotlin中字符串内嵌表达式的语法规则

```kotlin
"hello, ${obj.name}. nice to meet you!"
```

```
println("Cellphone(brand=" + brand + ", price=" + price + ")") 
println("Cellphone(brand=$brand, price=$price)")
```

## 函数参数的默认值

```kotlin
fun printParams(num: Int, str: String = "hello") { 
    println("num is $num , str is $str") 
} 
fun main() { 
    printParams(123) 
} 
```

Kotlin提供了另外一种神奇的机制，就是可以通过键值对的方式来传参，从而不 必像传统写法那样按照参数定义的顺序来传参。比如调用printParams()函数，我们还可以这 样写

```kotlin
fun printParams(num: Int = 100, str: String) { 
    println("num is $num , str is $str") 
} 
fun main() { 
    printParams(str = "world") 
}
```

